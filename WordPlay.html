<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://script.google.com" />
  <link rel="dns-prefetch" href="https://script.google.com" />
  <title>🪜 WordPlay — Climb • Collect • Conquer! 🪜</title>
   <script>
    const currentVersion = '1.0.2'; // *** Change this version number with every new deployment! ***
    const storedVersion = localStorage.getItem('gameVersion');
    
    if (storedVersion !== currentVersion) {
      localStorage.setItem('gameVersion', currentVersion);
      window.location.reload(true); // Forces a full, hard reload
    }
  </script>

  <style>
    :root{
      --ok:#22c55e;
      --ok-bg:#c1f0c1;
      --bad:#dc2626;
      --bad-bg:#fde2e2;
      --diamond-bg:#b2f5ea;
      --diamond-br:#0f766e;
      --ink:#0f172a;
      --muted:#64748b;
      --panel:#ffffff;
      --shadow:0 22px 72px rgba(2,6,23,.12);
      --radius:18px;
      --accent:#2563eb;
      --accent-rgb:37,99,235;
      --accent-dark:#1d4ed8;
      --bg-primary:#ffffff;
      --bg-secondary:#f8fafc;
      --border:#e2e8f0;

      --bubble-size: 52px;
      --bubble-gap: 12px;
      --max-letters: 8; /* will be set by JS */
      --word-line-width: calc(var(--max-letters) * var(--bubble-size) + (var(--max-letters) - 1) * var(--bubble-gap));
      --page-max:1600px;
      --ladder-rail-offset: 82px; /* distance from word container to rails */
    }

    [data-theme="dark"] {
      --ink:#f1f5f9;
      --muted:#94a3b8;
      --panel:#1e293b;
      --shadow:0 22px 72px rgba(0,0,0,.3);
      --accent:#60a5fa;
      --accent-rgb:96,165,250;
      --accent-dark:#3b82f6;
      --bg-primary:#0f172a;
      --bg-secondary:#1e293b;
      --border:#334155;
      --ok-bg:#064e3b;
      --bad-bg:#7f1d1d;
      --diamond-bg:#134e4a;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      margin:0;
      background: linear-gradient(135deg,#667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%);
      background-size: 400% 400%;
      animation: gradientShift 20s ease infinite;
      color:var(--ink);
      padding:clamp(1.5rem,3vw,3rem) clamp(1rem,3vw,3rem) 2rem;
      -webkit-font-smoothing:antialiased;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* center the entire game board horizontally */
    .app{
      width:100%;
      max-width:var(--page-max);
      margin:0 auto;
      display:block;
    }

    /* ENHANCED HERO */
    .hero{
      max-width:var(--page-max);
      margin:0 auto 2rem;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-radius:32px;
      box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25), 0 0 0 1px rgba(255,255,255,0.5);
      padding:clamp(3rem,5vw,4rem);
      text-align:center;
      position:relative;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.3);
    }

    [data-theme="dark"] .hero {
      background: rgba(30, 41, 59, 0.95); /* Darker, translucent panel */
      border: 1px solid rgba(96, 165, 250, 0.2); /* Subtle accent border */
      box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5), 0 0 0 1px rgba(96, 165, 250, 0.1);
    }

    /* CALENDAR ICON & DROPDOWN */
    .calendar-icon {
      position: fixed;
      top: 24px;
      left: 24px;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border: 3px solid var(--bad);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 20px;
      color: var(--bad);
      transition: all 0.3s ease;
      z-index: 2000;
      box-shadow:0 10px 30px rgba(220,38,38,.2);
    }

    .calendar-icon:hover {
      transform: scale(1.1) rotate(-10deg);
      box-shadow:0 15px 40px rgba(220,38,38,.3);
    }

    .calendar-icon::after {
      content: 'Previous Games';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 8px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .calendar-icon:hover::after {
      opacity: 1;
    }

    .calendar-dropdown {
      position: absolute;
      top: 96px;
      left: 24px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      padding: 1rem;
      box-shadow: 0 15px 35px rgba(0,0,0,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      min-width: 280px;
      display: none;
      z-index: 2001;
    }

    .calendar-dropdown.show {
      display: block;
      animation: dropdownSlide 0.2s ease-out;
    }

    @keyframes dropdownSlide {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      font-weight: 600;
      color: var(--accent);
    }

    .calendar-nav {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      color: var(--accent);
      transition: background 0.2s;
    }

    .calendar-nav:hover {
      background: rgba(37,99,235,0.1);
    }

    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 2px;
      text-align: center;
    }

    .calendar-day-header {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--muted);
      padding: 0.5rem 0;
    }

    .calendar-day {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
      position: relative;
    }

    .calendar-day:hover {
      background: rgba(37,99,235,0.1);
    }

    .calendar-day.today {
      background: var(--ok) !important;
      color: white !important;
      font-weight: 600;
    }

    .calendar-day.has-game {
      background: rgba(37,99,235,0.2);
      color: var(--accent);
      font-weight: 600;
    }

    .calendar-day.completed {
      background: linear-gradient(135deg, #fbbf24, #f59e0b) !important;
      color: #92400e !important;
      font-weight: 600;
    }

    .calendar-day.has-game::after {
      content: '•';
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 0.6rem;
      color: var(--accent);
    }

    .calendar-day.selected {
      background: var(--accent);
      color: white;
      cursor: default;
      font-weight: 600;
    }

    .calendar-day.loading {
      background: rgba(37,99,235,0.1);
      color: var(--accent);
      position: relative;
      pointer-events: none;
    }

    .calendar-day.loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      margin: -6px 0 0 -6px;
      border: 2px solid transparent;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .calendar-day.other-month {
      color: var(--muted);
      opacity: 0.5;
    }

    .calendar-instructions {
      text-align: center;
      margin-bottom: 0.5rem;
      font-size: 0.8rem;
      color: var(--muted);
      font-weight: 600;
    }

    #demoHint:hover {
      color: var(--accent);
      transform: scale(1.05);
    }

    #demoHint::after {
      content: 'Words with opposite meanings';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      font-size: 0.7rem;
      white-space: nowrap;
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      margin-bottom: 5px;
    }

    #demoHint:hover::after {
      opacity: 1;
    }

    .mobile-submit {
      display: none;
      padding: 0.5rem 1rem;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      margin-top: 0.25rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mobile-submit:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
    }

    @media (max-width: 768px) {
      :root {
        --bubble-size: 40px;
        --bubble-gap: 6px;
        --ladder-rail-offset: 20px;
      }
      
      body {
        padding: 0.25rem 0.25rem 0.5rem;
      }
      
      .calendar-dropdown {
        left: 0;
        right: 1rem;
        min-width: calc(100vw - 2rem);
        max-width: 320px;
        width: auto;
      }
      .mobile-submit {
        display: block;
      }
      
      .hero {
        padding: 2rem 1rem;
        margin-bottom: 1rem;
      }
      
      .ladder {
        padding: 0.5rem 0.5rem 1rem;
        width: 100%;
      }
      
      .ladder::before, .ladder::after {
        display: none;
      }
      
      .step::before {
        width: calc(100% - 1rem);
      }
      
      .word-hint-submit-wrapper {
        padding: 0.75rem;
        width: calc(100% - 1rem);
        margin: 0 auto;
      }
      
      .word-container {
        max-width: 100%;
        justify-content: center;
        flex-wrap: nowrap;
        overflow-x: auto;
        padding: 0 0.5rem;
      }
      
      .bubble {
        font-size: 1rem;
        -webkit-user-select: none;
        user-select: none;
        flex-shrink: 0;
        min-width: var(--bubble-size);
      }
      
      .final-word-container {
        width: calc(100% - 1rem);
        margin: 0 auto;
        padding: 1rem;
      }
      
      .final-word-container.small {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        margin: 0;
        border-radius: 16px 16px 0 0;
        z-index: 100;
      }
      
      .hud {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        margin: 0;
        border-radius: 0;
        padding: 0.5rem 1rem;
        z-index: 90;
      }
      
      .info-btn, .leaderboard-btn, .exit-btn {
        width: 32px;
        height: 32px;
        font-size: 12px;
        border-width: 2px;
      }
      
      .info-btn {
        top: 0.5rem;
        right: 0.5rem;
      }
      
      .leaderboard-btn {
        top: 0.5rem;
        right: 2.5rem;
      }
      
      .theme-toggle {
        top: 0.5rem;
        right: 4.5rem;
        width: 32px;
        height: 32px;
        font-size: 12px;
        border-width: 2px;
      }
      
      .exit-btn {
        top: 0.5rem;
        right: 6.5rem;
      }
    }

    .hero::before{
      content:'';
      position:absolute;
      top:-50%;
      left:-50%;
      width:200%;
      height:200%;
      background: conic-gradient(from 0deg, transparent, rgba(37,99,235,0.1), transparent, rgba(34,197,94,0.1), transparent);
      animation: rotate 20s linear infinite;
      pointer-events: none;
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .hero-inner {
      position: relative;
      z-index: 1;
    }

    h1{
      font-size:clamp(3.5rem,7vw,5.5rem);
      margin:0 0 1rem 0;
      font-weight:900;
      letter-spacing:-2px;
      line-height: 1.1;
      color: #0f172a; /* Fallback color */
    }
    
    .newspaper-text {
      background-image: url('https://hms.harvard.edu/sites/default/files/2024-07/750-Word-pile-GettyImages-183763383.jpg');
      background-size: 250px 250px;
      background-position: center;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
      filter: contrast(1.4) brightness(0.95);
      text-shadow: 2px 2px 0px rgba(255, 255, 255, 0.466), 4px 4px 8px rgba(0,0,0,0.5);
      -webkit-text-stroke: 1.5px rgba(0, 0, 0, 0.246);
      animation: newspaperShift 15s linear infinite;
    }

    @keyframes newspaperShift {
      from { background-position: 0% 0%; }
      to { background-position: -75px -75px; }
    }

    .subtitle {
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--accent);
      margin-bottom: 1.5rem;
      opacity: 0.9;
    }

    .tagline{
      color:var(--muted);
      max-width:65ch;
      margin:0 auto 2.5rem;
      font-size:1.2rem;
      line-height: 1.6;
    }

    .mode-cta{
      display:flex;
      gap:1.5rem;
      justify-content:center;
      flex-wrap:wrap;
      margin-bottom: 1.5rem;
      align-items: flex-start;
    }

    .mode-group {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1.5rem;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 24px;
      background: rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
    }

    .mode-group-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.8;
      margin-bottom: 0.5rem;
    }

    .mode-group-buttons {
      display: flex;
      gap: 1.5rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .btn{
      padding:1.2rem 2rem;
      border-radius:16px;
      border:none;
      cursor:pointer;
      font-weight:800;
      font-size: 1.1rem;
      letter-spacing:.5px;
      transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      min-width: 180px;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover{
      transform:translateY(-4px) scale(1.02);
      box-shadow:0 20px 40px rgba(0,0,0,0.15);
    }

    .btn:active {
      transform: translateY(-2px) scale(0.98);
    }

    .primary{
      background:linear-gradient(135deg,#667eea,#764ba2);
      color:#fff;
      box-shadow:0 10px 30px rgba(102,126,234,0.3);
    }

    .secondary{
      background:linear-gradient(135deg,#f093fb,#f5576c);
      color:#fff;
      box-shadow:0 10px 30px rgba(240,147,251,0.3);
    }

    .minor{
      background: rgba(255,255,255,0.9);
      color: var(--accent);
      border: 2px solid rgba(37,99,235,0.2);
      box-shadow:0 8px 25px rgba(37,99,235,0.1);
    }
    
    .unlimited{
      background:linear-gradient(135deg,#10b981,#059669);
      color:#fff;
      box-shadow:0 10px 30px rgba(16,185,129,0.3);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid rgba(255,255,255,0.3);
    }

    .stat-item {
      text-align: center;
      padding: 1rem;
      background: rgba(255,255,255,0.1);
      border-radius: 16px;
      backdrop-filter: blur(10px);
    }

    .stat-number {
      font-size: 2rem;
      font-weight: 900;
      color: var(--accent);
      display: block;
    }

    #dailyStreakStat {
      color: var(--bad);
    }

    .stat-label {
      font-size: 0.9rem;
      color: var(--muted);
      margin-top: 0.5rem;
    }

    /* HUD */
    .panel{
      max-width:var(--page-max);
      margin:0 auto 1rem;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:1rem;
      border: 1px solid rgba(255,255,255,0.2);
    }

    [data-theme="dark"] .panel {
      background: rgba(15, 23, 42, 0.9); /* Darker, translucent panel */
      border: 1px solid rgba(96, 165, 250, 0.2); /* Subtle accent border */
    }

    .hud{
      display:flex;
      gap:1rem;
      align-items:center;
      justify-content:center;
      position:sticky;
      top:14px;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-bottom:1px solid #eaf1ff;
      z-index:60;
    }

    [data-theme="dark"] .hud {
      background: rgba(15, 23, 42, 0.9);
      border-bottom: 1px solid var(--border);
    }

    .links-counter{
      font-variant-numeric:tabular-nums;
      padding:.6rem 1.2rem;
      border-radius:14px;
      background:linear-gradient(135deg,#eef6ff,#f5fbff);
      border:2px solid rgba(37,99,235,.12);
      color:#134e9e;
      min-width:140px;
      text-align:center;
      font-weight:800;
      font-size: 1.1rem;
    }

    [data-theme="dark"] .links-counter,
    [data-theme="dark"] .wrong-guesses-counter,
    [data-theme="dark"] .timer {
      background: rgba(var(--accent-rgb), 0.1);
    }

    .wrong-guesses-counter{
      font-variant-numeric:tabular-nums;
      padding:.6rem 1.2rem;
      border-radius:14px;
      background:linear-gradient(135deg,#eef6ff,#f5fbff);
      border:2px solid rgba(37,99,235,.12);
      color:#134e9e;
      min-width:140px;
      text-align:center;
      font-weight:800;
      font-size: 1.1rem;
    }

    .timer{
      font-variant-numeric:tabular-nums;
      padding:.6rem 1.2rem;
      border-radius:14px;
      background:linear-gradient(135deg,#eef6ff,#f5fbff);
      border:2px solid rgba(37,99,235,.12);
      color:#134e9e;
      min-width:140px;
      text-align:center;
      font-weight:800;
      font-size: 1.1rem;
    }

    .timer.blink{color:var(--bad);animation:blink 1s steps(2,end) infinite}
    @keyframes blink{50%{opacity:.35}}

    /* CENTERED LADDER THEME */
    .game-panel{max-width:var(--page-max);margin:0 auto;display:flex;flex-direction:column;align-items:center;width:100%;}
    .ladder{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:1rem;
      margin:4rem auto 0;
      position:relative;
      padding:1.5rem 0 1rem;
      width: 100%;
      max-width: 100%;
    }

    /* vertical rails - span visible word area */
    .ladder::before, .ladder::after{
      content:'';
      position:absolute;
      top:0.5rem;
      bottom:0.5rem;
      width:12px;
      background:
        linear-gradient(90deg, 
          #8B4513 0%, 
          #A0522D 20%, 
          #CD853F 40%, 
          #D2B48C 60%, 
          #A0522D 80%, 
          #8B4513 100%
        );
      border-radius:6px;
      z-index:0;
      box-shadow: 
        inset 2px 0 4px rgba(139,69,19,0.3),
        inset -2px 0 4px rgba(139,69,19,0.3),
        0 4px 8px rgba(0,0,0,0.2);
      border: 1px solid #654321;
    }

    .ladder::before{
      left: calc(50% - var(--word-line-width)/2 - var(--ladder-rail-offset));
    }
    .ladder::after{
      left: calc(50% + var(--word-line-width)/2 + var(--ladder-rail-offset));
    }

    .step{
      width:100%;
      display:flex;
      flex-direction: column;
      justify-content:center;
      align-items:center;
      position:relative;
      margin-bottom:4rem;
    }

    .step.hidden {
      display: none;
    }

    /* Enhanced rung behind each step */
    .step::before{
      content:'';
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      width:calc(var(--word-line-width) + 2 * var(--ladder-rail-offset));
      height:16px;
      background:linear-gradient(135deg,#f8fafc,#e2e8f0,#f1f5f9);
      border-radius:12px;
      z-index:1;
      box-shadow:
        0 4px 12px rgba(2,6,23,.06),
        inset 0 1px 2px rgba(255,255,255,0.8);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    [data-theme="dark"] .step::before {
      background: linear-gradient(135deg, #334155, #1e293b, #334155);
      border-color: rgba(96, 165, 250, 0.1);
    }

    .step.gold-rung::before{
      background:linear-gradient(135deg,#fbbf24,#f59e0b,#d97706);
      border: 1px solid #b45309;
      box-shadow:
        0 4px 12px rgba(251,191,36,.3),
        inset 0 1px 2px rgba(255,255,255,0.8);
    }

    .word-hint-submit-wrapper{
      position:relative;
      z-index:2;
      display:flex;
      flex-direction: column;
      align-items:center;
      gap:0.5rem;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border:2px solid rgba(255,255,255,0.3);
      border-radius:16px;
      padding:1rem;
      width:max-content;
      margin:0 auto;
      box-sizing:border-box;
      box-shadow: 
        0 10px 30px rgba(0,0,0,0.1),
        0 1px 0 rgba(255,255,255,0.6) inset;
    }

    [data-theme="dark"] .word-hint-submit-wrapper {
      background: rgba(var(--bg-secondary), 0.95);
      border-color: rgba(var(--accent-rgb), 0.2);
    }

    .step.gold-rung .word-hint-submit-wrapper{
      background: linear-gradient(135deg, rgba(251,191,36,0.2), rgba(245,158,11,0.15));
      border:2px solid rgba(217,119,6,0.3);
      box-shadow: 
        0 10px 30px rgba(251,191,36,0.2),
        0 1px 0 rgba(255,255,255,0.8) inset;
    }
    .word-container{
      display:flex;
      gap:var(--bubble-gap);
      justify-content:center;
      /* Let the container grow to fit its content */
      width: auto;
      max-width: var(--word-line-width);
      flex-wrap: wrap; /* Allow wrapping for very long words on small screens */
    }
    
    .space-separator {
        width: calc(var(--bubble-size) / 2);
        flex-shrink: 0;
    }

    .word-container .bubble{box-sizing:border-box}

    .bubble{
      width:var(--bubble-size);
      height:var(--bubble-size);
      border-radius:50%;
      border:3px solid #e2e8f0;
      background: linear-gradient(135deg, #ffffff, #f8fafc);
      text-align:center;
      line-height:calc(var(--bubble-size) - 6px);
      text-transform:uppercase;
      font-weight:800;
      font-size: 1.2rem;
      transition: all .2s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        0 4px 12px rgba(0,0,0,0.1),
        0 1px 0 rgba(255,255,255,0.8) inset;
    }

    [data-theme="dark"] .bubble {
      background: linear-gradient(135deg, #334155, #1e293b);
      border-color: #475569;
      color: #f1f5f9; /* Change letter color to light grey/white in dark mode */
    }

    .bubble:hover{
      transform:translateY(-6px) scale(1.08);
      box-shadow:0 15px 35px rgba(37,99,235,.15);
      border-color: var(--accent);
    }

    .bubble:focus-visible{
      outline:none;
      box-shadow:0 0 0 4px rgba(37,99,235,.3);
      transform:translateY(-4px) scale(1.05);
      border-color: var(--accent);
    }

    @keyframes finalLetterReveal {
      0% { transform: scale(0.8) rotateY(90deg); opacity: 0; }
      60% { transform: scale(1.1) rotateY(0deg); opacity: 1; }
      100% { transform: scale(1); }
    }

    .final-bubble.reveal-animation {
      animation: finalLetterReveal 0.5s ease-out forwards;
      background: linear-gradient(135deg, var(--ok-bg), #a7f3d0);
      border-color: var(--ok);
    }

    [data-theme="dark"] .final-bubble.reveal-animation {
      background: linear-gradient(135deg, var(--ok-bg), #059669);
      border-color: var(--ok);
    }

    .correct{
      background:linear-gradient(135deg, var(--ok-bg), #a7f3d0);
      border-color:var(--ok);
      animation: correctPulse 0.6s ease-out;
    }

    @keyframes correctPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    @keyframes wordMoveUp {
      0% { 
        transform: translateY(0) scale(1); 
        opacity: 1;
      }
      100% { 
        transform: translateY(-40px) scale(0.95); 
        opacity: 0.7;
      }
    }

    [data-theme="dark"] .correct {
      background: linear-gradient(135deg, var(--ok-bg), #059669);
      border-color: var(--ok);
    }

    .word-moving-up {
      animation: wordMoveUp 0.6s ease-out;
      z-index: 10;
    }

    .incorrect{
      background:linear-gradient(135deg, var(--bad-bg), #fecaca);
      border-color:var(--bad);
      animation: incorrectShake 0.5s ease-out;
    }

    [data-theme="dark"] .incorrect {
      background: linear-gradient(135deg, var(--bad-bg), #991b1b);
      border-color: var(--bad);
    }

    @keyframes incorrectShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-8px); }
      75% { transform: translateX(8px); }
    }

    .green-diamond{
      background:linear-gradient(135deg, var(--diamond-bg), #5eead4);
      border:3px solid var(--diamond-br);
      box-shadow:
        inset 0 2px 4px rgba(0,0,0,.02),
        0 0 20px rgba(15,118,110,0.3),
        0 4px 12px rgba(0,0,0,0.1);
      animation: diamondGlow 2s ease-in-out infinite;
    }
    
    [data-theme="dark"] .green-diamond {
      background: linear-gradient(135deg, var(--diamond-bg), #0d9488);
      border-color: var(--diamond-br);
    }

    @keyframes diamondGlow {
      0%, 100% { box-shadow: inset 0 2px 4px rgba(0,0,0,.02), 0 0 20px rgba(15,118,110,0.2), 0 4px 12px rgba(0,0,0,0.1); }
      50% { box-shadow: inset 0 2px 4px rgba(0,0,0,.02), 0 0 30px rgba(15,118,110,0.4), 0 6px 15px rgba(0,0,0,0.15); }
    }

    /* hint styling */
    .hint-outside{
      color:var(--muted);
      font-style:italic;
      font-size: 1rem;
      text-align: center;
      padding: 0.5rem 1rem;
      background: rgba(100,116,139,0.1);
      border-radius: 12px;
      margin-top: 0.5rem;
      backdrop-filter: blur(10px);
    }

    /* Down arrow with hint centered between words */
    .down-arrow{
      position:absolute;
      bottom:-4rem;
      left:50%;
      transform:translateX(-50%);
      z-index:10;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.95);
      border-radius: 12px;
      padding: 6px 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: 1px solid rgba(255,255,255,0.8);
    }

    [data-theme="dark"] .down-arrow {
      background: rgba(var(--bg-secondary), 0.95);
      border-color: rgba(var(--accent-rgb), 0.2);
    }

    .arrow-hint{
      font-size: 0.75rem;
      color: var(--muted);
      font-style: italic;
      margin-bottom: 3px;
      text-align: center;
      white-space: nowrap;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      justify-content: center;
    }
    
    @media (max-width: 768px) {
      .arrow-hint {
        white-space: normal;
        max-width: calc(100vw - 4rem);
        line-height: 1.3;
        word-break: break-word;
      }
      
      .down-arrow {
        max-width: calc(100vw - 2rem);
        left: 50%;
        transform: translateX(-50%);
      }
    }
    
    .info-icon-hint {
      font-style: normal;
      font-weight: 900;
      font-size: 0.7rem;
      color: var(--accent);
      opacity: 0.7;
    }

    .arrow-hint:hover {
      color: var(--accent);
      transform: scale(1.05);
    }
    
    .hint-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      font-size: 0.7rem;
      white-space: nowrap;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      margin-bottom: 5px;
    }
    
    .hint-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 4px solid transparent;
      border-top-color: rgba(0,0,0,0.9);
    }
    
    .arrow-hint:hover .hint-tooltip {
      opacity: 1;
    }

    .down-arrow svg{
      width:16px;
      height:16px;
      stroke:var(--accent);
      opacity:.7;
    }

    @keyframes bounceArrow{
      0%{transform:translateX(-50%) translateY(0)}
      50%{transform:translateX(-50%) translateY(4px)}
      100%{transform:translateX(-50%) translateY(0)}
    }

    .down-arrow.animate{animation:bounceArrow 2s ease-in-out infinite}

    .final-word-container{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:1rem;
      margin-bottom:3rem;
      margin-top:2rem;
      padding: 1rem;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.08);
      border: 1px solid rgba(255,255,255,0.3);
      transition: all 0.3s ease;
      width: 95%;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }

    .final-word-container.small{
      position: sticky;
      bottom: 10rem;
      z-index: 5;
      padding: 0.5rem 1rem;
      font-size: 0.8rem;
      opacity: 0.95;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      gap: 0;
      width: 95%;
      max-width: 600px;
      justify-content: center;
    }

    .final-word-container.expanded{
      position: sticky;
      bottom: 1rem;
      z-index: 65; /* Above HUD */
      padding: 2rem;
      font-size: 1rem;
      opacity: 1;
      box-shadow: 0 15px 35px rgba(0,0,0,0.1);
      width: 95%;
      max-width: 1000px;
    }

    .final-word-container.small{
      position: sticky;
      bottom: 10rem;
      z-index: 5;
      padding: 0.5rem 1rem;
      font-size: 0.8rem;
      opacity: 0.95;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      gap: 0;
      width: 95%;
      max-width: 600px;
      justify-content: center;
    }

    .final-word-container.expanded{
      position: static;
      padding: 2rem;
      font-size: 1rem;
      opacity: 1;
      box-shadow: 0 15px 35px rgba(0,0,0,0.1);
      width: 95%;
      max-width: 1000px;
    }

    [data-theme="dark"] .final-word-container {
      background: rgba(15, 23, 42, 0.9);
      border-color: rgba(var(--accent-rgb), 0.2);
    }

    #finalWordInputContainer {
        /* This container reuses .word-container styles */
        margin-bottom: 1rem;
        display: none; /* Initially hidden */
    }

    #secretLettersDisplay {
      position: sticky;
      bottom: 8rem;
      z-index: 1;
      background: rgba(255,255,255,0.9);
      padding: 0.5rem;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    #finalHint {
      background: linear-gradient(135deg, #fbbf24, #f59e0b);
      color: #92400e;
      padding: 1rem 1.5rem;
      border-radius: 16px;
      font-weight: 700;
      font-size: 1.1rem;
      text-align: center;
      box-shadow: 0 4px 12px rgba(251,191,36,0.3);
      border: 2px solid #d97706;
      animation: hintGlow 2s ease-in-out infinite;
    }

    @keyframes hintGlow {
      0%, 100% { box-shadow: 0 4px 12px rgba(251,191,36,0.3); }
      50% { box-shadow: 0 6px 20px rgba(251,191,36,0.5); }
    }

    [data-theme="dark"] #secretLettersDisplay {
      background: rgba(var(--bg-secondary), 0.9);
    }
    
    /* Keyboard shortcuts help */
    .shortcuts-hint {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.8rem;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .shortcuts-hint.show {
      opacity: 1;
    }
      
      .shortcuts-hint {
        display: none;
      }

    /* Info demo animations */
    .demo{display:flex;flex-direction:column;gap:.8rem;align-items:center;margin-top:1rem}
    .demo-row{display:flex;gap:10px;align-items:center}
    .demo-row .bubble{width:40px;height:40px;line-height:34px;font-weight:700;border-width:2px;font-size: 1rem;}
    .demo-secret{display:flex;gap:8px;margin-top:.8rem}
    .demo-slot{
      width:38px;
      height:38px;
      border-radius:8px;
      border:2px dashed #cbd5e0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:var(--diamond-br);
      background: rgba(178,245,234,0.2);
    }

    .demo .typing .bubble{background:#fff;border-color:#cbd5e0}
    .demo .typing .bubble.typed{background:var(--ok-bg);border-color:var(--ok)}
    .demo .typing .bubble.wrong{background:var(--bad-bg);border-color:var(--bad)}
    .demo .typing .bubble.gold {
      background: linear-gradient(135deg, #fef3c7, #fde68a);
      border-color: #f59e0b;
      color: #92400e;
      font-weight: 700;
    }


    /* Enhanced confetti */
    .confetti{position:absolute;inset:0;pointer-events:none;overflow:hidden}
    .confetti span{
      position:absolute;
      width:12px;
      height:16px;
      border-radius:3px;
      opacity:.95;
      transform-origin:center;
      animation:confettiFall 1500ms linear forwards
    }

    @keyframes confettiFall{
      0%{transform:translateY(-10vh) rotate(0) scale(.8);opacity:1}
      100%{transform:translateY(110vh) rotate(1080deg) scale(1.2);opacity:0}
    }

    /* Enhanced popup */
    .popup-overlay{
      position:fixed;
      inset:0;
      display:flex;
      justify-content:center;
      align-items:center;
      background:rgba(2,6,23,.6);
      backdrop-filter: blur(8px);
      z-index:2100;
    }

    .popup{
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      padding:2rem;
      border-radius:24px;
      box-shadow:0 25px 50px rgba(0,0,0,0.3);
      max-width:640px;
      width:92%;
      text-align:center;
      border: 2px solid rgba(255,255,255,0.3);
      animation: popupSlideIn 0.3s ease-out;
    }

    @keyframes popupSlideIn {
      from { transform: translateY(-20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    /* Enhanced modals */
    .modal{
      display:none;
      position:fixed;
      inset:0;
      justify-content:center;
      align-items:center;
      z-index:2200;
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(8px);
    }

    .modal-card{
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      padding:2rem;
      border-radius:20px;
      box-shadow:0 25px 50px rgba(0,0,0,0.3);
      max-width:720px;
      width:92%;
      max-height:90vh;
      overflow-y:auto;
      border: 2px solid rgba(255,255,255,0.3);
      animation: modalSlideIn 0.3s ease-out;
    }
    
    .sortable-header {
        cursor: pointer;
        user-select: none;
    }
    .sortable-header:hover {
        background: rgba(37,99,235,0.1) !important;
    }

    @keyframes modalSlideIn {
      from { transform: scale(0.9) translateY(-20px); opacity: 0; }
      to { transform: scale(1) translateY(0); opacity: 1; }
    }

    .modal-head{display:flex;justify-content:space-between;align-items:center}
    .link-btn{
      background:transparent;
      border:none;
      color:var(--muted);
      cursor:pointer;
      padding:.6rem 1rem;
      border-radius:12px;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .link-btn:hover {
      background: rgba(37,99,235,0.1);
      color: var(--accent);
    }

    /* Enhanced focus indicators */
    .link-btn:focus{outline:none}
    .link-btn:focus-visible{box-shadow:0 0 0 3px rgba(37,99,235,.2);border-radius:12px}
    #closeLbBtn:focus-visible{box-shadow:0 0 0 4px rgba(16,185,129,.2)}

    /* Enhanced pulse */
    .pulse{animation:pulseGlow 2s infinite;}
    @keyframes pulseGlow{
      0%{box-shadow:0 0 0 0 rgba(37,99,235,0.4)}
      50%{box-shadow:0 0 0 20px rgba(37,99,235,0.1)}
      100%{box-shadow:0 0 0 0 rgba(37,99,235,0.0)}
    }

    /* Enhanced info button */
    .info-btn{
      position:fixed;
      top:24px;
      right:24px;
      width:64px;
      height:64px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border:3px solid var(--accent);
      color:var(--accent);
      font-weight:900;
      z-index:2000;
      cursor:pointer;
      box-shadow:0 10px 30px rgba(37,99,235,.2);
      font-size:20px;
      transition: all 0.3s ease;
    }

    .info-btn:hover {
      transform: scale(1.1) rotate(10deg);
      box-shadow:0 15px 40px rgba(37,99,235,.3);
    }
    
    .info-btn::after {
      content: 'How to Play';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 8px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }
    .info-btn:hover::after { opacity: 1; }

    /* Leaderboard button */
    .leaderboard-btn{
      position:fixed;
      top:24px;
      right:100px;
      width:64px;
      height:64px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border:3px solid #f59e0b;
      color:#f59e0b;
      font-weight:900;
      z-index:2000;
      cursor:pointer;
      box-shadow:0 10px 30px rgba(245,158,11,.2);
      font-size:20px;
      transition: all 0.3s ease;
    }

    #leaderboardIconBtn:hover {
      transform: scale(1.1) rotate(10deg);
      box-shadow:0 15px 40px rgba(245,158,11,.3);
    }

    #leaderboardIconBtn::after {
      content: 'Hall of Fame';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 8px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    #leaderboardIconBtn:hover::after {
      opacity: 1;
    }

    /* Exit button */
    .exit-btn{
      position:fixed;
      top:24px;
      left:24px;
      width:64px;
      height:64px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border:3px solid var(--bad);
      color:var(--bad);
      font-weight:900;
      z-index:2000;
      cursor:pointer;
      box-shadow:0 10px 30px rgba(220,38,38,.2);
      font-size:20px;
      transition: all 0.3s ease;
    }

    .exit-btn:hover {
      transform: scale(1.1);
      box-shadow:0 15px 40px rgba(220,38,38,.3);
    }
    
    .exit-btn::after {
      content: 'Home';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 8px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }
    .exit-btn:hover::after { opacity: 1; }

    /* Dark Mode Toggle */
    .theme-toggle {
      position: fixed;
      top: 24px;
      right: 176px;
      width: 64px;
      height: 64px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border: 3px solid var(--muted);
      color: var(--muted);
      font-weight: 900;
      z-index: 2000;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(100,116,139,.2);
      font-size: 20px;
      transition: all 0.3s ease;
    }

    .theme-toggle:hover {
      transform: scale(1.1) rotate(15deg);
      box-shadow: 0 15px 40px rgba(245,158,11,.3);
    }

    .theme-toggle::after {
      content: 'Toggle Theme';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 8px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .theme-toggle:hover::after {
      opacity: 1;
    }

    /* Settings Button */
    .settings-btn {
      position:fixed;
      top:24px;
      right:176px;
      width:64px;
      height:64px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border:3px solid var(--muted);
      color:var(--muted);
      font-weight:900;
      z-index:2000;
      cursor:pointer;
      box-shadow:0 10px 30px rgba(100,116,139,.2);
      font-size:20px;
      transition: all 0.3s ease;
    }

    .settings-btn:hover {
      transform: scale(1.1) rotate(20deg);
      box-shadow:0 15px 40px rgba(245,158,11,.3);
    }

    /* Settings Modal Styles */
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 0;
      border-bottom: 1px solid var(--border);
    }
    .setting-row:last-child {
      border-bottom: none;
    }
    .setting-label {
      font-weight: 600;
      color: var(--ink);
    }
    .setting-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      cursor: pointer;
      font-weight: 600;
      color: var(--muted);
    }
    .setting-toggle.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .difficulty-toggle-group {
      display: flex;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    .difficulty-btn {
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
    }
    .difficulty-btn.active {
      background: var(--accent);
      color: white;
    }

    [data-tooltip] {
      position: relative;
      cursor: help;
    }

   [data-tooltip]::after {
  content: attr(data-tooltip);
  position: absolute;
  /* Position the tooltip below and to the right of the icon */
  top: 100%;
  left: 0; /* Align with the left edge of the icon */
  transform: translateX(-20%); /* Remove the centering transform */
  margin-top: 10px; /* Adds a small gap */

  background: rgba(0,0,0,0.9);
  color: white;
  padding: 0.5rem 0.75rem;
  border-radius: 8px;
  font-size: 0.8rem;
  white-space: nowrap;
  z-index: 10000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease;
  font-family: inherit;
  font-weight: 400;
  font-style: normal;
}

    [data-tooltip]:hover::after {
      opacity: 1;
    }

    [data-theme="dark"] .theme-toggle {
      background: rgba(30,41,59,0.95);
      border-color: #60a5fa;
      color: #60a5fa;
      box-shadow: 0 10px 30px rgba(96,165,250,.2);
    }

    [data-theme="dark"] .theme-toggle:hover {
      box-shadow: 0 15px 40px rgba(96,165,250,.3);
    }

    [data-theme="dark"] body {
      background: linear-gradient(135deg,#0f172a 0%, #1e293b 25%, #334155 50%, #475569 75%, #64748b 100%);
    }

    /* Enhanced shake animation */
    @keyframes shake {
      10%, 90% { transform: translateX(-3px); }
      20%, 80% { transform: translateX(4px); }
      30%, 50%, 70% { transform: translateX(-6px); }
      40%, 60% { transform: translateX(6px); }
    }
    .shake { animation: shake 400ms cubic-bezier(.36,.07,.19,.97) both; }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .pulse {
      animation: pulse 1s infinite;
    }

    .shortcut-item{
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.5rem;
      background: var(--bg-secondary);
      border-radius: 6px;
    }

    .shortcut-item kbd {
      background: var(--bg-primary);
      border: 1px solid var(--border);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-weight: 600;
    }

    .leaderboard-mode-filter {
      margin-top: 1rem;
    }
    .leaderboard-tabs .link-btn.active, .leaderboard-mode-filter .link-btn.active {
      background: var(--accent);
      color: white;
      font-weight: 700;
    }

    .leaderboard-mode-filter .link-btn.active {
      background: var(--accent);
      color: white;
      font-weight: 700;
    }

    /* Progress indicator */
    .progress-container {
      position: sticky;
      top: 0;
      z-index: 50;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(20px);
      padding: 0.5rem 0;
      margin-bottom: 1rem;
    }

    .progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(37,99,235,0.1);
      border-radius: 3px;
      overflow: hidden;
      max-width: var(--page-max);
      margin: 0 auto;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #22c55e);
      border-radius: 3px;
      transition: width 0.5s ease;
      width: 0%;
    }

    /* Floating particles background effect */
    .floating-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.6);
      border-radius: 50%;
      animation: float 20s infinite linear;
    }

    @keyframes float {
      0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
    }

    /* Responsive improvements */


    @media (max-width:540px){
      :root{
        --bubble-size: 44px;
        --bubble-gap: 6px;
      }
      
      body {
        padding: 0.25rem 0.25rem 0.5rem;
      }
      
      .hero { 
        padding: 1.5rem 0.75rem;
        margin-bottom: 0.5rem;
      }
      
      .stats-grid { 
        grid-template-columns: repeat(3, 1fr);
        gap: 0.25rem;
        max-width: 280px;
        margin: 0 auto;
      }
      
      .stat-item {
        padding: 0.5rem 0.25rem;
      }
      
      .stat-number {
        font-size: 1rem;
      }
      
      .stat-label {
        font-size: 0.7rem;
      }
      
      .mode-group {
        padding: 0.75rem;
      }
      
      .btn {
        min-width: 160px;
        padding: 1rem 1.5rem;
        font-size: 1rem;
      }
      
      .ladder {
        padding: 0.25rem 0.25rem 0.5rem;
      }
      
      .word-hint-submit-wrapper {
        padding: 0.75rem;
        width: calc(100% - 0.5rem);
      }
      
      .bubble {
        font-size: 1rem;
      }
      
      .hud {
        padding: 0.5rem 0.75rem;
      }
      
      .timer {
        min-width: 100px;
        font-size: 1rem;
      }
    }

    /* Loading animation */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(37,99,235,.3);
      border-radius: 50%;
      border-top-color: var(--accent);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Game Preview Overlay */
    .game-preview-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3000;
    }
    
    .game-preview-card {
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(20px);
      border-radius: 24px;
      padding: 3rem;
      max-width: 600px;
      width: 90%;
      text-align: center;
      box-shadow: 0 25px 50px rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.3);
    }
    
    .preview-ladder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
      margin: 2rem 0;
    }
    
    .preview-word {
      display: flex;
      gap: 8px;
      justify-content: center;
    }
    
    .preview-bubble {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 3px solid #e2e8f0;
      background: linear-gradient(135deg, #ffffff, #f8fafc);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      font-size: 1.2rem;
      text-transform: uppercase;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .preview-dots {
      color: var(--muted);
      font-size: 2rem;
      font-weight: 600;
    }
    
    .community-games-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .community-games-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 0.5rem;
    }
    
    .community-games-item-details {
      font-size: 0.9rem;
      color: var(--muted);
      margin-top: 0.25rem;
    }
  </style>
</head>
<body>
  <div class="floating-particles" id="particles"></div>
  
  <button id="infoButton" class="info-btn" aria-label="How to Play" type="button">?</button>

  <button id="calendar-icon" class="calendar-icon" aria-label="Previous Games" type="button">📅</button>
  <div class="calendar-dropdown" id="calendar-dropdown">
    <div class="calendar-header">
      <button class="calendar-nav" onclick="changeMonth(-1)">‹</button>
      <span id="calendar-month-year"></span>
      <button class="calendar-nav" onclick="changeMonth(1)">›</button>
    </div>
    <div class="calendar-instructions">
      🔵 Blue dates are playable previous games!
    </div>
    <div class="calendar-grid" id="calendar-grid"></div>
  </div>

  
  <button id="leaderboardIconBtn" class="leaderboard-btn" aria-label="Hall of Fame" type="button">🏆</button>
  
  <button id="exitButton" class="exit-btn" aria-label="Exit to Menu" type="button" style="display:none">🏠</button>
  
  <div id="shortcutsHint" class="shortcuts-hint">Press ? for keyboard shortcuts</div>

  <div class="app">
    <section id="hero" class="hero">
      <div class="hero-inner">
        <h1 class="newspaper-text">🪜 WordPlay 🪜</h1>
        <div class="subtitle">💎 Climb • Collect • Conquer 💎</div>
        <p class="tagline">Scale the ladder word by word, gather secret letters, and unlock the ultimate secret word. Choose your challenge: race against time, perfect your precision or simply practice.</p>
        
        <div class="mode-cta">
          <div class="mode-group">
            <div class="mode-group-title">Competitive</div>
            <div class="mode-group-buttons">
              <button id="timerModeBtn" class="btn primary" type="button">
                <span class="btn-content">⚡ Timed Challenge
                <small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">Race against the clock</small></span>
                <span class="btn-loading" style="display:none"><div class="loading"></div> Loading...</span>
              </button>
              <button id="normalModeBtn" class="btn secondary" type="button">
                <span class="btn-content">🎯 Precision Mode
                <small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">3 strikes and you're out</small></span>
                <span class="btn-loading" style="display:none"><div class="loading"></div> Loading...</span>
              </button>
            </div>
          </div>
          <div class="mode-group">
            <div class="mode-group-title">Casual</div>
            <div class="mode-group-buttons">
              <button id="unlimitedModeBtn" class="btn unlimited" type="button">
                <span class="btn-content">🔄 Unlimited Mode
                <small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">Practice with hints</small></span>
                <span class="btn-loading" style="display:none"><div class="loading"></div> Loading...</span>
              </button>
            </div>
          </div>

        </div>

        <div class="mode-group-title" style="margin-top:2.5rem;">Statistics</div>
        <div class="stats-grid">
          <div class="stat-item">
            <span id="wordsToClimbCount" class="stat-number"><div class="loading"></div></span>
            <div class="stat-label">Words</div>
          </div>
          <div class="stat-item">
            <span id="dailyStreakStat" class="stat-number">🔥 0</span>
            <div class="stat-label">Streak</div>
          </div>
          <div class="stat-item">
            <span id="nextGameCountdown" class="stat-number" style="color: var(--ok);">--:--:--</span>
            <div class="stat-label">Next Game</div>
          </div>
        </div>
        
        
        <div class="mode-cta" style="margin-top:1rem;margin-bottom:0">
          <div class="mode-group">
            <div class="mode-group-title">Custom Games</div>
            <div class="mode-group-buttons">
              <button id="createGameBtn" class="btn minor" type="button">
                <span class="btn-content">🎨 Create Game
                <small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">Build your own puzzle</small></span>
              </button>
              <button id="myGamesBtn" class="btn minor" type="button">
                <span class="btn-content">📁 My Games
                <small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">Play your creations</small></span>
              </button>
              <button id="communityGamesBtn" class="btn minor" type="button">
                <span class="btn-content">🌍 Community
                <small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">Play shared puzzles</small></span>
              </button>
            </div>
          </div>
        </div>
    </section>

    <div id="progressContainer" class="progress-container" style="display:none">
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill"></div>
      </div>
    </div>

    <div id="hud" class="panel hud" aria-live="polite" style="display:none">
      <div id="timer" class="timer">1:30</div>
      <div id="linksCounter" class="links-counter">Links Solved: 0/0</div>
      <div id="wrongGuessesCounter" class="wrong-guesses-counter">Incorrect Guesses Remaining: 3</div>
    </div>

    <div id="gamePanel" class="panel game-panel" style="display:none">
      <div id="ladder" class="ladder"></div>

      <div id="finalWordContainer" class="final-word-container">
        <div id="secretLettersDisplay" style="font-size:0.9rem;font-weight:600;margin:0">
          Secret Letters: <span id="secretLettersText" style="color:#0ea5e9;font-weight:900">_ _ _ _ _ _ _ _</span>
        </div>
        <div id="finalHint" style="color:var(--muted);margin-bottom:1rem;display:none;font-style:italic;font-size:1rem"></div>
        <div id="finalWordInputContainer" class="word-container" style="margin-bottom:1rem; display: none;"></div>
        <button id="finalSubmit" disabled class="btn primary" type="button" style="width:100%;margin-bottom:1rem">Submit</button>
        <div style="display:flex;gap:1rem;align-items:center;flex-wrap:wrap;justify-content:center">
          <button id="shuffleBtn" disabled class="btn minor" type="button">🔄 Shuffle</button>
          <button id="shareBtn" disabled class="btn secondary" type="button">📤 Share</button>
        </div>
        <div id="shareTip" style="color:var(--accent);opacity:0;transition:all .3s;font-weight:600;margin-top:0.5rem">✅ Copied to clipboard!</div>
      </div>
    </div>

    <div id="popupContainer"></div>
  </div>

  <div id="leaderboardModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="lbTitle">
      <div class="modal-head">
        <h3 id="lbTitle" style="margin:0;color:var(--accent);font-size:1.5rem; flex-grow: 1;">🏆 Hall of Fame</h3>
        <div id="leaderboardTabs" class="leaderboard-tabs">
            <button id="globalLbBtn" class="link-btn active" type="button">🌍 Global</button>
            <button id="localLbBtn" class="link-btn" type="button">🏠 Your Best</button>
        </div>
        <div>
          <button id="clearLbBtn" class="link-btn" title="Clear leaderboard" type="button" style="display:none;">Clear All</button>
          <button id="closeLbBtn" class="link-btn" title="Close leaderboard" type="button">✕</button>
        </div>
      </div>
      <div id="leaderboardModeFilter" class="leaderboard-mode-filter">
        <button id="lbFilterAll" data-mode-filter="all" class="link-btn active" type="button">All</button>
        <button id="lbFilterTimer" data-mode-filter="timer" class="link-btn" type="button">⚡ Timed</button>
        <button id="lbFilterNormal" data-mode-filter="normal" class="link-btn" type="button">🎯 Precision</button>
        <button id="lbFilterUnlimited" data-mode-filter="unlimited" class="link-btn" type="button">🔄 Unlimited</button>
      </div>
      <div id="leaderboardBody" style="margin-top:1.5rem;color:var(--muted)">
        <div style="text-align:center;padding:2rem;color:var(--muted)">
          <div class="loading"></div>
          <div style="margin-top:1rem">Loading scores...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="modal-head">
        <h3 id="settingsTitle" style="margin:0;color:var(--accent);font-size:1.5rem">⚙️ Settings</h3>
        <button id="closeSettingsBtn" class="link-btn" aria-label="Close" type="button">✕</button>
      </div>
      <div style="margin-top:1.5rem; display: grid; gap: 1.5rem;">
        <div class="setting-row">
          <label for="themeToggleSwitch" class="setting-label">Theme</label>
          <button id="themeToggleSwitch" class="setting-toggle" aria-label="Toggle Theme">
            <span class="toggle-icon">🌙</span> Dark
          </button>
        </div>
        <div class="setting-row">
          <label for="soundToggleSwitch" class="setting-label">Sound Effects</label>
          <button id="soundToggleSwitch" class="setting-toggle" aria-label="Toggle Sound Effects">
            <span class="toggle-icon">🔊</span> On
          </button>
        </div>
        <div class="setting-row">
          <label for="difficultyToggle" class="setting-label">
            Final Word Difficulty
            <span class="info-icon-hint" style="margin-left: 2px; cursor: pointer;" data-tooltip="Easy: Secret letters are grouped by word. Hard: All secret letters are scrambled together.">ⓘ</span>
          </label>
          <div class="difficulty-toggle-group">
            <button id="difficultyEasy" class="difficulty-btn active" data-difficulty="easy">Easy</button>
            <button id="difficultyHard" class="difficulty-btn" data-difficulty="hard">Hard</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <button id="settingsButton" class="theme-toggle" aria-label="Settings" type="button">⚙️</button>

  <div id="infoPopup" class="modal" aria-hidden="true" style="display:none">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="infoTitle">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 id="infoTitle" style="margin:0;color:var(--accent);font-size:1.5rem">🎮 How to Play</h3>
        <button id="closeInfoX" class="link-btn" aria-label="Close" type="button">✕</button>
      </div>

      <div id="infoPagesContainer" style="margin-top:1.5rem; min-height: 320px; position: relative;">
        
        <div id="infoPage1" class="info-page" style="text-align:left; line-height:1.4; font-size:0.9rem;">
          <div style="font-weight:700;margin-bottom:0.8rem;color:var(--accent);font-size:1rem; text-align: center;">Instructions</div>
          <div style="padding:0.8rem;background:rgba(37,99,235,0.05);border-radius:8px;border-left:3px solid var(--accent)">
            <strong>🎯 Goal:</strong> Solve each word in the ladder based on the hint connecting them.
          </div>
           <div style="padding:0.8rem;background:rgba(34,197,94,0.05);border-radius:8px;border-left:3px solid var(--ok); margin-top: 0.8rem;">
            <strong>🫧 Special Letters:</strong> Collect the blue "secret letters" along the way to reveal clues for the final puzzle!
          </div>
          <div style="margin-top:1.5rem;">
            <strong style="display: block; text-align: center; margin-bottom: 1rem; font-size: 1rem; color: var(--accent);">Choose your challenge</strong>
            <ul style="list-style:none;padding:0;margin:0;display:grid;gap:0.8rem;">
              <li style="background:rgba(102,126,234,0.1);border-radius:8px;padding:0.8rem;display:flex;align-items:center;gap:0.8rem;">
                <span style="font-size: 1.5rem;">⚡</span>
                <div><strong style="color:var(--accent)">Timed:</strong> Race against the clock to solve the puzzle.</div>
              </li>
              <li style="background:rgba(240,147,251,0.1);border-radius:8px;padding:0.8rem;display:flex;align-items:center;gap:0.8rem;">
                <span style="font-size: 1.5rem;">🎯</span>
                <div><strong style="color:var(--accent)">Precision:</strong> You only have 3 wrong guesses. A wrong guess reveals a correct letter as a hint.</div>
              </li>
               <li style="background:rgba(16,185,129,0.1);border-radius:8px;padding:0.8rem;display:flex;align-items:center;gap:0.8rem;">
                <span style="font-size: 1.5rem;">♾️</span>
                <div><strong style="color:var(--accent)">Unlimited:</strong> No pressure! Infinite time, guesses, and access to hints.</div>
              </li>
            </ul>
          </div>
        </div>

        <div id="infoPage2" class="info-page" style="display:none;">
          <div style="font-weight:700;margin-bottom:0.5rem;color:var(--accent);font-size:1rem; text-align: center;">Word Connections</div>
          <p style="text-align: center; margin-top: 0; margin-bottom: 1.5rem; color: var(--muted); font-size: 0.9rem;">Hints show how a word relates to the one below it.</p>
          <div style="display:grid; gap: 1.2rem; justify-content: center;">
            <div class="demo-row" style="flex-direction: column; align-items: center;">
              <div style="display:flex;gap:4px;"><div class="bubble demo-bubble">H</div><div class="bubble demo-bubble">O</div><div class="bubble demo-bubble">T</div></div>
              <div class="arrow-hint" data-hint="antonym" style="margin: 0.3rem 0; position: relative; transform: none; box-shadow: none; padding: 4px 8px; background: rgba(100,116,139,0.1); border-radius: 6px;">
                antonym<span class="info-icon-hint" style="margin-left: 4px;">ⓘ</span>
                <div class="hint-tooltip"></div>
              </div>
              <div style="display:flex;gap:4px;"><div class="bubble demo-bubble">C</div><div class="bubble demo-bubble">O</div><div class="bubble demo-bubble">L</div><div class="bubble demo-bubble">D</div></div>
              <div class="arrow-hint" data-hint="wordplay" style="margin: 0.3rem 0; position: relative; transform: none; box-shadow: none; padding: 4px 8px; background: rgba(100,116,139,0.1); border-radius: 6px;">
                wordplay<span class="info-icon-hint" style="margin-left: 4px;">ⓘ</span>
                <div class="hint-tooltip"></div>
              </div>
              <div style="display:flex;gap:4px;"><div class="bubble demo-bubble">W</div><div class="bubble demo-bubble">A</div><div class="bubble demo-bubble">R</div></div>
              <div class="arrow-hint" data-hint="one-letter addition: distort" style="margin: 0.3rem 0; position: relative; transform: none; box-shadow: none; padding: 4px 8px; background: rgba(100,116,139,0.1); border-radius: 6px;">
                one-letter addition: distort<span class="info-icon-hint" style="margin-left: 4px;">ⓘ</span>
                <div class="hint-tooltip"></div>
              </div>
              <div style="display:flex;gap:4px;"><div class="bubble demo-bubble">W</div><div class="bubble demo-bubble">A</div><div class="bubble demo-bubble">R</div><div class="bubble demo-bubble">P</div></div>
            </div>
          </div>
          <style>.demo-bubble { width:32px;height:32px;line-height:26px;font-size:0.9rem; border-width: 2px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }</style>
        </div>

        <div id="infoPage3" class="info-page" style="display:none;">
          <div class="demo" aria-hidden="true" style="margin-top:1rem;padding:0.8rem;background:rgba(100,116,139,0.05);border-radius:8px">
              <div style="font-weight:700;margin-bottom:0.8rem;color:var(--accent);font-size:1rem; text-align: center;">Live Example</div>
              <p style="text-align: center; margin-top: 0; margin-bottom: 1.5rem; color: var(--muted); font-size: 0.9rem;">Watch how letters are guessed, corrected, and collected.</p>
              <div id="demoRow1" style="display:flex;gap:4px;justify-content:center;margin-bottom:0.3rem">
                <div class="bubble" style="width:24px;height:24px;line-height:18px;font-size:0.7rem"></div>
                <div class="bubble" style="width:24px;height:24px;line-height:18px;font-size:0.7rem"></div>
                <div class="bubble" style="width:24px;height:24px;line-height:18px;font-size:0.7rem"></div>
              </div>
              <div id="demoHint" title="Words with opposite meanings" style="text-align:center;margin:0.2rem 0;padding:2px 6px;background:rgba(255,255,255,0.9);border-radius:6px;font-size:0.65rem;color:var(--muted);font-style:italic;font-weight:700;display:inline-block;cursor:pointer;transition:all 0.2s ease;position:relative">antonym</div>
              <div id="demoRow2" style="display:flex;gap:4px;justify-content:center;margin-bottom:0.4rem">
                <div class="bubble" style="width:24px;height:24px;line-height:18px;font-size:0.7rem"></div>
                <div class="bubble" style="width:24px;height:24px;line-height:18px;font-size:0.7rem"></div>
                <div class="bubble" style="width:24px;height:24px;line-height:18px;font-size:0.7rem"></div>
                <div class="bubble" style="width:24px;height:24px;line-height:18px;font-size:0.7rem"></div>
              </div>
              <div style="margin:0.3rem 0;color:var(--muted);font-size:0.7rem;text-align:center">↓ Secret Letters ↓</div>
              <div id="demoSecret" style="display:flex;gap:4px;justify-content:center">
                <div class="demo-slot" style="width:24px;height:24px;line-height:20px;font-size:0.7rem">_</div>
                <div class="demo-slot" style="width:24px;height:24px;line-height:20px;font-size:0.7rem">_</div>
                <div class="demo-slot" style="width:24px;height:24px;line-height:20px;font-size:0.7rem">_</div>
              </div>
            </div>
        </div>

        <div id="infoPage4" class="info-page" style="display:none;">
          <div style="font-weight:700;margin-bottom:0.5rem;color:var(--accent);font-size:1rem; text-align: center;">The Final Challenge</div>
          <p style="text-align: center; margin-top: 0; margin-bottom: 1.5rem; color: var(--muted); font-size: 0.9rem;">Complete the ladder to unlock the final word. Unscramble the secret letters you've collected to solve it!</p>
          <div style="padding: 1rem; background:rgba(100,116,139,0.05);border-radius:8px; display: flex; flex-direction: column; align-items: center; gap: 1rem;">
            <div>
              <div style="font-size:0.9rem;font-weight:600;margin-bottom: 0.5rem;">Your Scrambled Letters:</div>
              <div style="display:flex; gap: 8px; font-weight: 900; color: #0ea5e9; justify-content: center; font-family: monospace; font-size: 1.2rem; background: rgba(14, 165, 233, 0.1); padding: 0.25rem 0.75rem; border-radius: 6px;">
                <span>P</span> <span>S</span> <span>O</span> <span>T</span>
              </div>
            </div>
            <div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #92400e; padding: 0.5rem 1rem; border-radius: 12px; font-weight: 700; font-size: 0.9rem; text-align: center; border: 2px solid #d97706; display: block !important;">Found on a dalamation</div>
            <div class="word-container" style="gap: 8px;">
                <div class="bubble demo-bubble correct">S</div>
                <div class="bubble demo-bubble correct">P</div>
                <div class="bubble demo-bubble correct">O</div>
                <div class="bubble demo-bubble correct">T</div>
            </div>
          </div>
        </div>
      </div>

      <div id="infoNav" style="margin-top:1.5rem;display:flex;justify-content:space-between;align-items:center; border-top: 1px solid var(--border); padding-top: 1rem;">
        <button id="infoBackBtn" class="btn minor" type="button" style="padding: 0.8rem 1.5rem; visibility: hidden;">← Back</button>
        <div id="infoPageIndicator" style="font-size: 0.9rem; color: var(--muted); font-weight: 600;">1 / 4</div>
        <button id="infoNextBtn" class="btn primary" type="button" style="padding: 0.8rem 1.5rem;">Next →</button>
      </div>
    </div>
  </div>

  <!-- Custom Prompt Modal -->
  <div id="customPromptModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="promptTitle">
      <h3 id="promptTitle" style="margin:0 0 1rem;color:var(--accent);font-size:1.5rem">Enter Your Name</h3>
      <p id="promptMessage" style="margin-top:0; color:var(--muted)">Please enter your name for the leaderboard (max 12 characters).</p>
      <input id="promptInput" type="text" maxlength="12" style="width:100%;padding:0.75rem;border:2px solid var(--border);border-radius:8px;font-size:1rem;margin-bottom:1.5rem;">
      <div style="display:flex;gap:1rem;justify-content:flex-end;">
        <button id="promptCancelBtn" class="btn minor" type="button" style="padding:0.8rem 1.5rem">Cancel</button>
        <button id="promptOkBtn" class="btn primary" type="button" style="padding:0.8rem 1.5rem">OK</button>
      </div>
    </div>
  </div>

  <!-- Custom Confirm Modal -->
  <div id="customConfirmModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
      <div style="text-align: center; margin-bottom: 1.5rem;">
        <span style="font-size: 3rem;">🏠</span>
      </div>
      <h3 id="confirmTitle" style="margin:0 0 0.5rem;color:var(--accent);font-size:1.5rem;text-align:center;">Are you sure?</h3>
      <p id="confirmMessage" style="margin-top:0; color:var(--muted); text-align:center;">Your current game progress will be lost.</p>
      <div style="display:flex;gap:1rem;justify-content:center;margin-top:2rem;">
        <button id="confirmCancelBtn" class="btn minor" type="button" style="padding:0.8rem 1.5rem">Cancel</button>
        <button id="confirmOkBtn" class="btn primary" type="button" style="padding:0.8rem 1.5rem">Exit to Menu</button>
      </div>
    </div>
  </div>

  <div id="gamePreviewOverlay" class="game-preview-overlay" style="display:none;">
    <div class="game-preview-card">
      <div style="margin-bottom: 2rem;">
        <div style="font-size: 3rem; margin-bottom: 1rem;">🪜</div>
        <h2 style="margin: 0 0 0.5rem; color: var(--accent); font-size: 1.8rem; font-weight: 700;">Ready to Climb?</h2>
        <p style="color: var(--muted); font-size: 1.1rem; margin: 0;">Connect the word</p>
      </div>
      <div id="previewLadder" class="preview-ladder"></div>
      <button id="startGameBtn" class="btn primary">🪜 Start Climbing</button>
    </div>
  </div>

  <!-- Keyboard Shortcuts Modal -->
  <div id="shortcutsModal" class="modal" aria-hidden="true">
      <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="shortcutsTitle">
          <div class="modal-head">
              <h3 id="shortcutsTitle" style="margin:0;color:var(--accent);font-size:1.5rem">⌨️ Keyboard Shortcuts</h3>
              <button id="closeShortcutsBtn" class="link-btn" aria-label="Close" type="button">✕</button>
          </div>
          <ul style="list-style: none; padding: 0; margin-top: 1.5rem; display: grid; gap: 1rem;">
              <li class="shortcut-item">
                  <kbd>Enter</kbd>
                  <span>Submit current word</span>
              </li>
              <li class="shortcut-item">
                  <kbd>↑</kbd> / <kbd>↓</kbd>
                  <span>Navigate between words</span>
              </li>
              <li class="shortcut-item">
                  <kbd>Ctrl</kbd> + <kbd>Z</kbd>
                  <span>Undo last letter typed</span>
              </li>
              <li class="shortcut-item">
                  <kbd>?</kbd>
                  <span>Show this shortcuts guide</span>
              </li>
              <li class="shortcut-item">
                  <kbd>Esc</kbd>
                  <span>Close any open modal or exit game</span>
              </li>
          </ul>
      </div>
  </div>

  <!-- Custom Confirm Modal -->
  <div id="customConfirmModal" class="modal" aria-hidden="true">
      <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
          <div style="text-align: center; margin-bottom: 1.5rem;"><span style="font-size: 3rem;">🏠</span></div>
          <h3 id="confirmTitle" style="margin:0 0 0.5rem;color:var(--accent);font-size:1.5rem;text-align:center;">Are you sure?</h3>
          <p id="confirmMessage" style="margin-top:0; color:var(--muted); text-align:center;">Your current game progress will be lost.</p>
          <div style="display:flex;gap:1rem;justify-content:center;margin-top:2rem;"><button id="confirmCancelBtn" class="btn minor" type="button" style="padding:0.8rem 1.5rem">Cancel</button><button id="confirmOkBtn" class="btn primary" type="button" style="padding:0.8rem 1.5rem">Exit to Menu</button></div>
      </div>
      </div>

  <!-- Custom Game Builder Modal -->
  <div id="gameBuilderModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="builderTitle">
      <div class="modal-head">
        <h3 id="builderTitle" style="margin:0;color:var(--accent);font-size:1.5rem">🎨 WordPlay Builder</h3>
        <button id="closeBuilderBtn" class="link-btn" aria-label="Close" type="button">✕</button>
      </div>
      <div style="margin-top:1rem">
        <div style="margin-bottom:1rem">
          <label for="gameNameInput" style="display:block;font-weight:600;margin-bottom:0.5rem">Game Name:</label>
          <input id="gameNameInput" type="text" placeholder="My Awesome Word Ladder" style="width:100%;padding:0.75rem;border:2px solid #e2e8f0;border-radius:8px;font-size:1rem" maxlength="50">
        </div>
        <div style="margin-bottom:1rem">
          <label style="display:block;font-weight:600;margin-bottom:0.5rem">Words:</label>
          <div style="display:flex;gap:0.5rem;align-items:center;padding:0.5rem;background:rgba(37,99,235,0.1);border-radius:8px;font-weight:600;color:var(--accent);font-size:0.9rem">
            <div style="width:160px">Word</div>
            <div style="width:240px">Hint</div>
            <div style="width:120px;text-align:center">Secret Letters</div>
            <div style="width:30px"></div>
            <div style="width:30px"></div>
          </div>
          <div id="wordBuilderContainer" style="display:flex;flex-direction:column;gap:0.5rem;min-height:150px"></div>
          <button id="addWordBtn" class="btn minor" type="button" style="margin-top:0.5rem;padding:0.5rem 1rem">+ Add Word</button>
        </div>
        <div style="margin-bottom:1rem">
          <label for="finalWordInput" style="display:block;font-weight:600;margin-bottom:0.5rem">Final Word:</label>
          <input id="finalWordInput" type="text" placeholder="SECRET" style="width:100%;padding:0.75rem;border:2px solid #e2e8f0;border-radius:8px;font-size:1rem" maxlength="20">
        </div>
        <div style="margin-bottom:1rem">
          <label for="finalHintInput" style="display:block;font-weight:600;margin-bottom:0.5rem">Final Hint:</label>
          <input id="finalHintInput" type="text" placeholder="Something hidden..." style="width:100%;padding:0.75rem;border:2px solid #e2e8f0;border-radius:8px;font-size:1rem" maxlength="100">
        </div>
        <div style="display:flex;gap:1rem;justify-content:flex-end;margin-top:2rem">
          <button id="saveGameBtn" class="btn primary" type="button">💾 Save Game</button>
        </div>
      </div>
    </div>
  </div>

  <!-- My Games Modal -->
  <div id="myGamesModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="myGamesTitle">
      <div class="modal-head">
        <h3 id="myGamesTitle" style="margin:0;color:var(--accent);font-size:1.5rem">📁 My Games</h3>
        <button id="closeMyGamesBtn" class="link-btn" aria-label="Close" type="button">✕</button>
      </div>
      <div id="myGamesBody" style="margin-top:1rem"></div>
    </div>
  </div>

  <!-- Community Games Modal -->
  <div id="communityGamesModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="communityGamesTitle">
      <div class="modal-head">
        <h3 id="communityGamesTitle" style="margin:0;color:var(--accent);font-size:1.5rem">🌍 Community Games</h3>
        <button id="closeCommunityGamesBtn" class="link-btn" aria-label="Close" type="button">✕</button>
      </div>
      <div id="communityGamesBody" style="margin-top:1rem"></div>
    </div>
  </div>

  <script>
document.addEventListener('DOMContentLoaded', () => {
  const $id = id => document.getElementById(id);
  
  const _0x1a2b = 'aHR0cHM6Ly9zY3JpcHQuZ29vZ2xlLmNvbS9tYWNyb3Mvcy9BS2Z5Y2J3UnU2UGt0RkhFeVZ4bU1TSnVFVno4dUN0SEE5aTZjNjIxYmd6MjZXY1VmWXVMNlZ3Zjl2ZUdlZGgzRjl2VWgzbjkvZXhlYw==';
  const _0x3c4d = atob(_0x1a2b);
  
  // Custom Games Storage
  const CUSTOM_GAMES_KEY = 'wordLadderCustomGames_v2';

  // Game configuration - loaded from Google Sheets
  let gameConfig = {
    ladderData: [],
    finalWord: '',
    finalHint: ''
  };
  
  // Expose function to update game config
  window.updateGameConfig = function(newConfig) {
    gameConfig = { ...gameConfig, ...newConfig };
  };
  
  // Puzzle cache for instant loading
  const GAME_VERSION = 'v1.02'; // Increment this to force a cache reset on new deployments
  let puzzleCache = new Map();
  const CACHE_KEY = `wordLadderPuzzleCache_${GAME_VERSION}`;
  const CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours
  // Add this line at the top of your main script block
  const cacheBuster = new Date().getTime();
  const DATA_CACHE_KEY = 'wordLadderDataCache_v1';
  
  // Batch load all puzzles
  window.handleBatchGameData = function(data) {
    console.log("Received batch data:", data);
    try {
      if (data && data.puzzles && typeof data.puzzles === 'object' && Object.keys(data.puzzles).length > 0) {
        console.log(`🎯 Processing ${Object.keys(data.puzzles).length} puzzles`);
        puzzleCache.clear();
        Object.entries(data.puzzles).forEach(([date, puzzleData]) => {
          // Ensure puzzleData is a valid object before setting
          if (puzzleData && typeof puzzleData === 'object' && Array.isArray(puzzleData.ladderData)) {
            const ladderWithDiamonds = puzzleData.ladderData.map(item => ({
              word: item.word,
              hint: item.hint,
              diamondIndex: item.diamondIndex || [] // Ensure diamondIndex is always an array
            }));
            const cacheEntry = {
              ladderData: ladderWithDiamonds,
              finalWord: puzzleData.finalWord || '',
              finalHint: puzzleData.finalHint || ''
            };
            puzzleCache.set(date, cacheEntry);
          }
        });
        savePuzzleCache();
        console.log('💾 Batch data cached successfully');
        
        // Always load today's game after batch load
        const today = getEstDateString();
        if (puzzleCache.has(today)) {
          console.log('🎮 Loading today\'s game from batch cache');
          if (loadPuzzleFromCache(today)) {
            // Update the game config variables
            ladderData = gameConfig.ladderData;
            manualFinalWord = gameConfig.finalWord;
            manualFinalHint = gameConfig.finalHint;
            // This is a good place to re-enable buttons
            hideButtonLoading(timerModeBtn);
            hideButtonLoading(normalModeBtn);
            hideButtonLoading(unlimitedModeBtn);
            if ($id('wordsToClimbCount')) $id('wordsToClimbCount').textContent = ladderData.length;
          }
        } else {
          console.log(`⚠️ No puzzle found for today (${today})`);
        }
      } else {
        console.log('❌ No puzzles in batch data');
      }
    } catch (error) {
      console.error("💥 Failed to handle batch game data:", error);
    }
  };
  
  // Load puzzle from cache instantly
  function loadPuzzleFromCache(dateStr) {
    console.log(`⚡ Loading puzzle from cache for ${dateStr}`);
    const puzzle = puzzleCache.get(dateStr);
    if (!puzzle) {
      console.log(`❌ No cached puzzle for ${dateStr}`);
      return false;
    }
    
    console.log(`✅ Found cached puzzle: ${puzzle.ladderData?.length || 0} words`);
    gameConfig.ladderData = puzzle.ladderData || [];
    gameConfig.finalWord = puzzle.finalWord || '';
    gameConfig.finalHint = puzzle.finalHint || '';
    
    console.log('🎯 Puzzle loaded instantly from cache');
    return true;
  }
  
  // JSONP callback function for Google Apps Script (fallback)
  window.handleGameData = function(data) {
    try {
      if (data && data.error) {
        throw new Error(`Error from Google Sheets: ${data.error}`);
      }
      if (data.values && data.values.length > 1) {
        const rows = data.values.slice(1);
        const newLadderData = [];
        let newFinalWord = '';
        let newFinalHint = '';
        
        rows.forEach(row => {
          if (row[0] === 'FINAL') {
            newFinalWord = row[1] || '';
            newFinalHint = row[2] || 'Hint: A secret word awaits…';
          } else if (row[0] && row[0] !== 'FINAL') {
            const wordData = { word: row[0].toUpperCase() };
            if (row[1]) wordData.hint = row[1];
            if (row[2] !== '' && row[2] !== null && row[2] !== undefined) {
              if (typeof row[2] === 'number') {
                wordData.diamondIndex = [row[2]];
              } else {
                const cellValue = String(row[2]).trim();
                if (cellValue && cellValue !== '') {
                  if (cellValue.includes(',')) {
                    const indices = cellValue.split(',').map(i => parseInt(i.trim())).filter(i => !isNaN(i));
                    if (indices.length > 0) wordData.diamondIndex = indices;
                  } else {
                    const index = parseInt(cellValue);
                    if (!isNaN(index)) wordData.diamondIndex = [index];
                  }
                }
              }
            }
            newLadderData.push(wordData);
          }
        });
        
        if (newLadderData.length > 0) {
          gameConfig.ladderData = newLadderData;
          gameConfig.finalWord = newFinalWord;
          gameConfig.finalHint = newFinalHint;
        }
      }
    } catch (error) {
      console.error("Failed to handle game data:", error);
    }
  };
  
  // Load config from Google Sheets using JSONP with retry mechanism (fallback)
  window.loadGameConfig = function(retryCount = 0) {
    return new Promise((resolve, reject) => {
      try {
        if (_0x3c4d) {
          const script = document.createElement('script');
          script.src = `${_0x3c4d}?tab=game&date=${dateStr}&callback=handleDateGameData&v=${Date.now()}`;
          
          const cleanup = () => {
            if (script.parentNode) {
              document.head.removeChild(script);
            }
          };
          
          script.onerror = () => {
            cleanup();
            if (retryCount < 3) {
              setTimeout(() => {
                window.loadGameConfig(retryCount + 1).then(resolve).catch(reject);
              }, 1000 * (retryCount + 1));
            } else {
              reject(new Error('Google Sheets unavailable after retries'));
            }
          };
          
          script.onload = () => {
            cleanup();
            setTimeout(() => {
              if (gameConfig.ladderData && gameConfig.ladderData.length > 0) {
                resolve();
              } else {
                if (retryCount < 3) {
                  setTimeout(() => {
                    window.loadGameConfig(retryCount + 1).then(resolve).catch(reject);
                  }, 1000 * (retryCount + 1));
                } else {
                  reject(new Error('No data received from Google Sheets after retries'));
                }
              }
            }, 50);
          };
          
          
          document.head.appendChild(script);
          
          // Timeout after 10 seconds
          setTimeout(() => {
            cleanup();
            if (retryCount < 3) {
              setTimeout(() => {
                window.loadGameConfig(retryCount + 1).then(resolve).catch(reject);
              }, 1000 * (retryCount + 1));
            } else {
              reject(new Error('Google Sheets request timed out after retries'));
            }
          }, 10000);
        } else {
          reject(new Error('No Google Sheets URL configured'));
        }
      } catch (error) {
        reject(error);
      }
    });
  };
  

  
  // Use config values - will be updated after loading
  let ladderData = [];
  let manualFinalWord = '';
  let manualFinalHint = '';

  let clockInterval = null;
  let timeLeft = 180;
  
// Helper to get today's date string in EST/EDT
  function getEstDateString() {
    const now = new Date();
    // Use Intl.DateTimeFormat to reliably get the date parts in the target timezone
    const parts = new Intl.DateTimeFormat('en-US', {
        timeZone: 'America/New_York',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
    }).formatToParts(now).reduce((acc, part) => {
        acc[part.type] = part.value;
        return acc;
    }, {});
    const dateStr = `${parts.year}-${parts.month}-${parts.day}`;
    console.log(`📅 Today's EST date calculated as: ${dateStr}`);
    return dateStr;
  }

  // New function to handle the countdown timer
  function startNextGameCountdown() {
      const countdownEl = $id('nextGameCountdown');
      if (!countdownEl) return;

      const updateCountdown = () => {
          const now = new Date();
          const target = new Date();

          // Set target to tomorrow 00:00:00 in EST
          target.toLocaleString('en-US', { timeZone: 'America/New_York' });
          target.setDate(target.getDate() + 1);
          target.setHours(0, 0, 0, 0);

          const diff = target.getTime() - now.getTime();

          if (diff <= 0) {
              countdownEl.textContent = "New Game!";
              playSound('celebration');
              setTimeout(() => {
                  location.reload();
              }, 1000);
              return;
          }

          const hours = Math.floor((diff / (1000 * 60 * 60)) % 24).toString().padStart(2, '0');
          const minutes = Math.floor((diff / 1000 / 60) % 60).toString().padStart(2, '0');
          const seconds = Math.floor((diff / 1000) % 60).toString().padStart(2, '0');
          
          countdownEl.textContent = `${hours}:${minutes}:${seconds}`;
      };

      setInterval(updateCountdown, 1000);
      updateCountdown(); // Initial call
  }

  function getTimerDuration(wordCount) {
    if (wordCount <= 8) return 180;  // 3:00
    if (wordCount <= 12) return 210; // 3:30
    if (wordCount <= 15) return 240; // 4:00
    if (wordCount <= 18) return 270; // 4:30
    return 300; // 5:00
  }
  let incorrectWordGuesses = 0;
  let currentMode = null;
  let diamondLetters = [];
  let secretWord = '';
  const maxIncorrectGuesses = 3;
  let gameStartAt = null;
  let currentStep = 0;
  let isSubmitting = false;
  let revealedLetters = {}; // Track revealed letters per word index
  let hintsUsed = 0;
  let isExpanded = false; // Track if user has expanded all words

  function getLocalDateString(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }
  let gameIsOver = false;
  let selectedGameDate = null;
  let scrambledFinalWord = '';
  let isCustomGame = false;
  let isMobile = window.innerWidth <= 768;
  let currentIndex = 1; // Track current viewing position in 3-word view
  let undoStack = []; // Track actions for undo functionality
  let finalWordDifficulty = localStorage.getItem('wordLadderDifficulty') || 'easy';
  let soundEnabled = localStorage.getItem('wordLadderSound') !== 'false';
  let gameState = null; // For auto-save

  // popup auto-close handle
  let popupAutoCloseTimeout = null;

  const infoButton = $id('infoButton');
  const infoPopup = $id('infoPopup');
  const closeInfo = $id('closeInfo');
  const closeInfoX = $id('closeInfoX');
  const hero = $id('hero');
  const hud = $id('hud');
  const gamePanel = $id('gamePanel');
  const ladder = $id('ladder');
  const timer = $id('timer');
  const finalWordInputContainer = $id('finalWordInputContainer');
  const finalSubmit = $id('finalSubmit');
  const shuffleBtn = $id('shuffleBtn');
  const shareBtn = $id('shareBtn');
  const shareTip = $id('shareTip');
  const finalHint = $id('finalHint');
  const finalWordContainer = $id('finalWordContainer');
  const popupContainer = $id('popupContainer');
  const wrongGuessesCounter = $id('wrongGuessesCounter');
  const linksCounter = $id('linksCounter');
  const leaderboardModal = $id('leaderboardModal');
  const leaderboardBody = $id('leaderboardBody');
  const clearLbBtn = $id('clearLbBtn');
  const closeLbBtn = $id('closeLbBtn');
  const timerModeBtn = $id('timerModeBtn');
  const normalModeBtn = $id('normalModeBtn');
  const unlimitedModeBtn = $id('unlimitedModeBtn');
  const leaderboardBtn = $id('leaderboardBtn');
  const progressContainer = $id('progressContainer');
  const progressFill = $id('progressFill');
  const exitButton = $id('exitButton');
  const themeToggle = $id('themeToggle');
  const settingsButton = $id('settingsButton');
  const settingsModal = $id('settingsModal');
  const closeSettingsBtn = $id('closeSettingsBtn');
  const themeToggleSwitch = $id('themeToggleSwitch');
  const soundToggleSwitch = $id('soundToggleSwitch');
  const soundToggle = $id('soundToggle');
  const shortcutsModal = $id('shortcutsModal');
  const closeShortcutsBtn = $id('closeShortcutsBtn');
  
  
  // Custom Game Elements
  const createGameBtn = $id('createGameBtn');
  const myGamesBtn = $id('myGamesBtn');
  const communityGamesBtn = $id('communityGamesBtn');
  const gameBuilderModal = $id('gameBuilderModal');
  const myGamesModal = $id('myGamesModal');
  const communityGamesModal = $id('communityGamesModal');
  const closeBuilderBtn = $id('closeBuilderBtn');
  const closeMyGamesBtn = $id('closeMyGamesBtn');
  const closeCommunityGamesBtn = $id('closeCommunityGamesBtn');
  const addWordBtn = $id('addWordBtn');
  const saveGameBtn = $id('saveGameBtn');
  const myGamesBody = $id('myGamesBody');
  const gameNameInput = $id('gameNameInput');
  const finalWordInput = $id('finalWordInput');
  const finalHintInput = $id('finalHintInput');
  const wordBuilderContainer = $id('wordBuilderContainer');


  // Create floating particles
  function createFloatingParticles() {
    const container = $id('particles');
    if (!container) return;
    
    for (let i = 0; i < 15; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = Math.random() * 100 + '%';
      particle.style.animationDelay = Math.random() * 20 + 's';
      particle.style.animationDuration = (15 + Math.random() * 10) + 's';
      container.appendChild(particle);
    }
  }

  // Update progress bar
  function updateProgress() {
    if (!progressFill) return;
    const progress = (currentStep / ladderData.length) * 100;
    progressFill.style.width = progress + '%';
  }

  function trapFocus(container) {
    const selector = 'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])';
    const getFocusables = () => Array.from(container.querySelectorAll(selector)).filter(el => el.offsetParent !== null);
    function handle(e) {
      if (e.key !== 'Tab') return;
      const focusables = getFocusables();
      if (!focusables.length) return;
      const first = focusables[0];
      const last = focusables[focusables.length - 1];
      if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
      else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
    }
    container.addEventListener('keydown', handle);
    return () => container.removeEventListener('keydown', handle);
  }

  function setMaxLettersCSSVar(){
    const maxLen = ladderData.reduce((m,s)=>Math.max(m,s.word.length),0);
    document.documentElement.style.setProperty('--max-letters', maxLen);
  }

  let untrapModal = null;
  let infoDemoInterval = null;

  function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

  async function playDemoOnce() {
    const demoRow1 = $id('demoRow1')?.querySelectorAll('.bubble');
    const demoRow2 = $id('demoRow2')?.querySelectorAll('.bubble');
    const demoSlots = $id('demoSecret')?.querySelectorAll('.demo-slot');
    
    if (!demoRow1 || !demoRow2 || !demoSlots) return;

    const word1 = ['H', 'O', 'T'];
    const word2 = ['C', 'O', 'L', 'D'];
    const incorrectWord2_typed = ['O', 'X', 'D']; // What the user types
    const secretLetters = ['T', 'L'];

    // 1. Reset and Initial State
    [...demoRow1, ...demoRow2].forEach(b => {
      b.className = 'bubble';
      b.textContent = '';
      b.style.cssText = 'width:24px;height:24px;line-height:18px;font-size:0.7rem;';
    });
    demoSlots.forEach(s => { s.textContent = '_'; s.className = 'demo-slot'; });

    // First word is always solved
    word1.forEach((letter, i) => {
      demoRow1[i].textContent = letter;
      demoRow1[i].classList.add('correct');
      if (i === 2) { // Diamond letter 'T'
        demoRow1[i].classList.add('green-diamond');
      }
    });
    demoSlots[0].textContent = secretLetters[0];
    
    // Set up second word initial state
    demoRow2[2].classList.add('green-diamond'); // 'L' is always a diamond
    demoRow2[0].textContent = word2[0]; // 'C' is pre-filled

    await sleep(1500);

    // 2. Animate typing incorrect second word (E, X, D)
    for (let i = 0; i < incorrectWord2_typed.length; i++) {
      demoRow2[i + 1].textContent = incorrectWord2_typed[i];
      await sleep(200);
    }
    
    // 3. Show incorrect state
    for (let i = 1; i < demoRow2.length; i++) {
        demoRow2[i].classList.add('incorrect');
    }
    await sleep(1200);

    // 4. Reveal a hint (gold letter)
    for (let i = 1; i < demoRow2.length; i++) {
        demoRow2[i].classList.remove('incorrect');
    }
    demoRow2[1].classList.add('gold'); // 'O' is correct
    await sleep(1200);

    // 5. Animate typing correct word
    // Clear the incorrect/hinted letters first
    for (let i = 1; i < word2.length; i++) {
        demoRow2[i].classList.remove('gold');
        demoRow2[i].textContent = '';
    }
    demoRow2[0].textContent = 'C'; // Re-assert C
    await sleep(500);
    
    // Now type the rest of the correct word
    for (let i = 1; i < word2.length; i++) {
      demoRow2[i].textContent = word2[i];
      await sleep(200);
    }

    // 6. Show correct state and collect letter
    demoRow2.forEach((b, i) => {
      b.classList.add('correct');
      if (i === 2) { // Diamond letter 'L'
        b.classList.add('green-diamond');
      }
    });
    await sleep(800);
    demoSlots[1].textContent = secretLetters[1];
    await sleep(1500);

    // 7. Final unscramble animation
    const s1 = demoSlots[0];
    const s2 = demoSlots[1];
    const letter1 = s1.textContent;
    const letter2 = s2.textContent;

    s1.textContent = letter2;
    s2.textContent = letter1;
    await sleep(700);
    s1.textContent = letter1;
    s2.textContent = letter2;
    await sleep(2000);
  }

  function startInfoDemoLoop() {
    stopInfoDemo();
    const loop = async () => {
      while (infoDemoInterval) {
        await playDemoOnce();
        await sleep(1000);
      }
    };
    infoDemoInterval = true;
    loop();
  }

  function stopInfoDemo() {
    infoDemoInterval = false;
  }

  function totalDiamondCount(){
    // Exclude the first and last words from the count, as their diamonds are pre-filled.
    return ladderData.slice(1, -1).reduce((acc, step) => {
      if (!step.diamondIndex) return acc;
      return acc + (Array.isArray(step.diamondIndex) ? step.diamondIndex.length : 0);
    }, 0);
  }
  function underscoreString(n){ return Array.from({length:n}).map(()=>'_').join(' '); }
  function flatDiamondLetters(){ return diamondLetters.flat().filter(Boolean); }
  function updateSecretLettersDisplay(){
    const display = $id('secretLettersText');
    if (!display) return;
    const finalWordLength = (manualFinalWord || '').replace(/ /g, '').length;
    if (finalWordLength === 0) return; // Don't update if there's no final word.

    const flat = flatDiamondLetters();
    const total = finalWordLength;
    const shown = Array.from({length: total}).map((_,i)=> flat[i] || '_').join(' ');
    display.textContent = shown;
    display.style.color = '#0ea5e9';
    display.style.fontWeight = '900';
  }
  
  function scramble(str) {
      const words = str.split(' ');
      const scrambledWords = words.map(word => {
          let scrambled;
          let attempts = 0;
          do {
              const letters = word.split('');
              for (let i = letters.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [letters[i], letters[j]] = [letters[j], letters[i]];
              }
              scrambled = letters.join('');
              attempts++;
          } while (scrambled === word && attempts < 50);
          return scrambled;
      });
      return scrambledWords.join(' ');
  }
  
  function getHintExplanation(hint) {
    const explanations = {
      'rhyme': 'Words that sound similar at the end',
      'synonym': 'Words with the same or similar meaning',
      'antonym': 'Words with opposite meanings',
      'wordplay': 'The previous word comes before this word in a common phrase',
      'one-letter change': 'Change exactly one letter to get the next word',
      'one-letter addition': 'Add exactly one letter to get the next word',
      'one-letter removal': 'Remove exactly one letter to get the next word',
      'consisting of': 'The next word is made up only of letters from the previous word',
      'homonym': 'Words that sound the same but have different meanings',
      'anagram': 'Words that can be rearranged to form each other',
    };
    
    // Find matching explanation
    for (const [key, explanation] of Object.entries(explanations)) {
      if (hint.toLowerCase().includes(key)) {
        return explanation;
      }
    }
    
    return 'How this word connects to the next one';
  }

  /* Streak Counter */
  const STREAK_KEY = 'wordLadderStreak_v1';
  const COMPLETED_DATES_KEY = 'wordLadderCompletedDates_v1';

  function updateStreakAndStats() {
    const streakEl = $id('dailyStreakStat');
    if (!streakEl) return;

    let streakData;
    try {
        streakData = JSON.parse(localStorage.getItem(STREAK_KEY)) || { streak: 0, lastPlayed: null };
    } catch {
        streakData = { streak: 0, lastPlayed: null };
    }

    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split('T')[0];

    // If last played was not today or yesterday, the streak is broken.
    if (streakData.lastPlayed && streakData.lastPlayed !== todayStr && streakData.lastPlayed !== yesterdayStr) {
        streakData.streak = 0;
    }
    
    streakEl.innerHTML = `🔥 ${streakData.streak}`;
  }

   function recordPuzzleCompletion(gameDate) {
    const completedDates = new Set(JSON.parse(localStorage.getItem(COMPLETED_DATES_KEY) || '[]'));
    completedDates.add(gameDate);
    localStorage.setItem(COMPLETED_DATES_KEY, JSON.stringify(Array.from(completedDates)));
  }

  function recordWinStreak() {
    const today = new Date();
    const todayStr = today.toISOString().split('T')[0];

    let streakData;
    try {
        streakData = JSON.parse(localStorage.getItem(STREAK_KEY)) || { streak: 0, lastPlayed: null };
    } catch {
        streakData = { streak: 0, lastPlayed: null };
    }
    
    const yesterday = new Date(today);
    yesterday.setDate(today.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split('T')[0];

    if (streakData.lastPlayed === todayStr) {
        return; // Already recorded a win for today
    }

    if (streakData.lastPlayed === yesterdayStr) {
        streakData.streak++;
    } else {
        streakData.streak = 1;
    }

    streakData.lastPlayed = todayStr;
    localStorage.setItem(STREAK_KEY, JSON.stringify(streakData));
    updateStreakAndStats();
  }

  /* Enhanced Leaderboard with better storage and sorting */
  const LB_KEY = 'wordLadderLeaderboard_v1';
  let leaderboardSortState = { key: 'mode', order: 'asc' };
  let leaderboardModeFilter = 'all';

  const PLAYER_NAME_KEY = 'wordLadderPlayerName_v1';

  // NEW: Custom Prompt Function
  function customPrompt(title, message, defaultValue = '') {
    console.log('Opening custom prompt...');
    return new Promise(resolve => {
      const modal = $id('customPromptModal');
      const titleEl = $id('promptTitle');
      const messageEl = $id('promptMessage');
      const inputEl = $id('promptInput');
      const okBtn = $id('promptOkBtn');
      const cancelBtn = $id('promptCancelBtn');

      titleEl.textContent = title;
      messageEl.textContent = message;
      inputEl.value = defaultValue;
      inputEl.placeholder = defaultValue;

      let untrap;

      const escHandler = (e) => { if (e.key === 'Escape') close(null); };
      const okClickHandler = () => close(inputEl.value);
      const cancelClickHandler = () => close(null); // Resolve with null on cancel
      const modalClickHandler = (e) => { if (e.target === modal) close(null); };

      const close = (value) => {
        console.log('Closing prompt with value:', value);
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        
        okBtn.removeEventListener('click', okClickHandler);
        cancelBtn.removeEventListener('click', cancelClickHandler);
        modal.removeEventListener('click', modalClickHandler); // This will now work
        document.removeEventListener('keydown', escHandler);
        if (untrap) untrap();
        resolve(value);
      };

      // Remove any old listeners before adding new ones
      okBtn.removeEventListener('click', okClickHandler);
      cancelBtn.removeEventListener('click', cancelClickHandler);

      okBtn.addEventListener('click', okClickHandler);
      cancelBtn.addEventListener('click', cancelClickHandler);
      
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      document.addEventListener('keydown', escHandler);
      untrap = trapFocus(modal);
      inputEl.focus();
      inputEl.select();
    });
  }

  async function getPlayerName() {
    console.log('Getting player name...');
    let playerName = localStorage.getItem(PLAYER_NAME_KEY);

    if (!playerName) {
      const entered = await customPrompt(
        "Enter Your Name",
        "Please enter your name for the leaderboard (max 12 characters):",
        "Player"
      );
      
      console.log('Player entered:', entered);
      playerName = (entered && String(entered).trim()) ? String(entered).trim().substring(0, 12) : "Anonymous";
      localStorage.setItem(PLAYER_NAME_KEY, playerName);
    }
    return playerName;
  }

  function loadLeaderboard(){ try{return JSON.parse(localStorage.getItem(LB_KEY))||[];}catch{return []} }
  function saveLeaderboard(list){ try{localStorage.setItem(LB_KEY, JSON.stringify(list));}catch{} }
  function saveScore({name, mode, success, timeUsedSec=null, wrongs=null, finalWord, when=(new Date()).toISOString(), hints=null, gameDate}){ 
    if (!success) return;
    
    if (gameDate) {
      recordPuzzleCompletion(gameDate);
    }
    
    // Only update streak if it's today's game
    if (!isCustomGame && gameDate === getEstDateString()) {
      recordWinStreak();
    }

    const list = loadLeaderboard(); 
    list.push({name, mode, timeUsedSec, wrongs, finalWord, when, gameDate, hints}); 
    const sorted = list.sort((a,b)=>{ 
      if (a.mode !== b.mode) {
        const order = ['timer', 'normal', 'unlimited'];
        return order.indexOf(a.mode) - order.indexOf(b.mode);
      }
      if (a.mode === 'timer') {
        const timeDiff = (a.timeUsedSec ?? 9999) - (b.timeUsedSec ?? 9999);
        if (timeDiff !== 0) return timeDiff;
        return (a.wrongs ?? 999) - (b.wrongs ?? 999); // Tie-breaker
      }
      if (a.mode === 'normal') {
        const wrongDiff = (a.wrongs ?? 999) - (b.wrongs ?? 999);
        if (wrongDiff !== 0) return wrongDiff;
        return (a.timeUsedSec ?? 9999) - (b.timeUsedSec ?? 9999); // Tie-breaker
      }
      if (a.mode === 'unlimited') {
        const hintDiff = (a.hints ?? 999) - (b.hints ?? 999);
        if (hintDiff !== 0) return hintDiff;
        return (a.timeUsedSec ?? 9999) - (b.timeUsedSec ?? 9999); // Tie-breaker
      }
      return 0;
    }).slice(0,20); 
    saveLeaderboard(sorted); 
  }

  function formatDateForDisplay(dateInput) {
    if (!dateInput) return '—';

    // It could be an ISO string from a timestamp, or a YYYY-MM-DD string
    const date = new Date(dateInput);

    // If it's a YYYY-MM-DD string, new Date() will parse it as UTC midnight.
    // We need to adjust for the user's timezone to prevent off-by-one day errors.
    if (typeof dateInput === 'string' && !dateInput.includes('T')) {
        date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
    }

    if (isNaN(date.getTime())) {
      return 'Invalid Date';
    }

    return date.toLocaleDateString(undefined, { year: '2-digit', month: 'numeric', day: 'numeric' });
  }

  function submitGlobalScore(scorePayload) {
    const safePayload = {
      mode: scorePayload.mode || "normal",
      timeUsedSec: typeof scorePayload.timeUsedSec === "number" ? scorePayload.timeUsedSec : 0,
      wrongs: typeof scorePayload.wrongs === "number" ? scorePayload.wrongs : 0,
      hints: typeof scorePayload.hints === "number" ? scorePayload.hints : null,
      finalWord: scorePayload.finalWord || "",
      gameDate: scorePayload.gameDate || new Date().toISOString().slice(0, 10),
      name: scorePayload.name && scorePayload.name.trim() ? scorePayload.name.trim() : "Anonymous"
    };
    
    const script = document.createElement('script');
    const params = new URLSearchParams({
      action: 'saveScore',
      mode: safePayload.mode,
      timeUsedSec: safePayload.timeUsedSec,
      wrongs: safePayload.wrongs,
      hints: safePayload.hints,
      finalWord: safePayload.finalWord,
      gameDate: safePayload.gameDate,
      name: safePayload.name,
      callback: 'handleScoreSubmission',
      _: Date.now()
    });
    script.src = `${_0x3c4d}?${params}`;
    
    window.handleScoreSubmission = function(response) {
      // Score submission completed
    };
    
    const cleanup = () => {
      if (script.parentNode) {
        document.head.removeChild(script);
      }
    };
    
    script.onload = () => {
      setTimeout(cleanup, 1000);
    };
    
    script.onerror = () => {
      cleanup();
    };
    
    setTimeout(() => {
      if (script.parentNode) {
        cleanup();
      }
    }, 10000);
    
    document.head.appendChild(script);
  }
  
  function isDateCompleted(dateStr) {
    const completedDates = new Set(JSON.parse(localStorage.getItem(COMPLETED_DATES_KEY) || '[]'));
    const localScores = loadLeaderboard();
    return completedDates.has(dateStr) || localScores.some(score => score.gameDate === dateStr);
  }

  function renderLeaderboard(list, type = 'global'){ 
    if (!leaderboardBody) return; 

    if (list) {
        currentLeaderboardData = list;
    }
    const clearBtn = $id('clearLbBtn');
    if (clearBtn) clearBtn.style.display = type === 'local' ? 'inline-block' : 'none';
    const filteredList = leaderboardModeFilter === 'all'
        ? currentLeaderboardData
        : currentLeaderboardData.filter(score => score.mode === leaderboardModeFilter);
    
    setTimeout(() => {
      if (!filteredList.length){
        leaderboardBody.innerHTML = `
          <div style="text-align:center;padding:3rem;color:var(--muted)">
            <div style="font-size:3rem;margin-bottom:1rem">🏆</div>
            <div style="font-size:1.2rem;font-weight:600;margin-bottom:0.5rem">No champions yet!</div>
            <div>Be the first to conquer the ladder and claim your spot.</div>
          </div>
        `; 
        return; 
      } 
      
      const showMode = leaderboardModeFilter === 'all';
      const showTime = leaderboardModeFilter === 'all' || leaderboardModeFilter === 'timer';
      const showWrongs = leaderboardModeFilter === 'all' || leaderboardModeFilter === 'timer' || leaderboardModeFilter === 'normal';
      const showHints = leaderboardModeFilter === 'all' || leaderboardModeFilter === 'normal' || leaderboardModeFilter === 'unlimited';
      const showFinalWord = type === 'local';
      
      const rows = filteredList.map((r,i)=>{
     
        let mode = '❓ Unknown';
        if (r.mode === 'timer') mode = '⚡ Timed';
        if (r.mode === 'normal') mode = '🎯 Precision';
        if (r.mode === 'unlimited') mode = '🔄 Unlimited';
        const timeTxt = r.timeUsedSec != null ? msToClock(r.timeUsedSec * 1000) : '—';
        const wrongs = r.wrongs != null ? r.wrongs : '—'; 
        const hints = r.hints != null ? r.hints : '—'; 
        const displayDate = formatDateForDisplay(r.gameDate || r.when);
        const playerName = String(r.name || 'Anonymous').replace(/</g, "&lt;").replace(/>/g, "&gt;");
        const rankEmoji = i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : `${i+1}.`;
        return `
          <tr style="border-bottom:1px solid rgba(0,0,0,0.05)">
            <td style="padding:0.8rem;font-weight:600">${rankEmoji}</td>
            <td style="padding:0.8rem;font-weight:600;color:var(--accent)">${playerName}</td>
            ${showMode ? `<td style="padding:0.8rem; white-space: nowrap;">${mode}</td>` : ''}
            ${showFinalWord ? `<td style="padding:0.8rem;font-weight:600;color:var(--accent)">${r.finalWord||'—'}</td>` : ''}
            ${showTime ? `<td style="padding:0.8rem;font-family:monospace">${timeTxt}</td>` : ''}
            ${showWrongs ? `<td style="padding:0.8rem">${wrongs}</td>` : ''}
            ${showHints ? `<td style="padding:0.8rem">${hints}</td>` : ''}
            <td style="padding:0.8rem;color:var(--muted);font-size:0.9rem">${displayDate}</td>
          </tr>
        `;
      }).join(''); 
      
      const getSortIndicator = (key) => {
        if (leaderboardSortState.key === key) {
            return leaderboardSortState.order === 'asc' ? ' ▲' : ' ▼';
        }
        return '';
      };
      
      leaderboardBody.innerHTML = `
        <div style="overflow:auto;border-radius:12px;border:1px solid rgba(0,0,0,0.1)">
          <table style="width:100%;border-collapse:collapse;background:#fff">
            <thead>
              <tr style="background:linear-gradient(135deg,#f8fafc,#e2e8f0)">
                <th style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Rank</th>
                <th class="sortable-header" data-sort-key="name" style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Player${getSortIndicator('name')}</th>
                ${showMode ? `<th class="sortable-header" data-sort-key="mode" style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Mode${getSortIndicator('mode')}</th>` : ''}
                ${showFinalWord ? `<th class="sortable-header" data-sort-key="finalWord" style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Final Word${getSortIndicator('finalWord')}</th>` : ''}
                ${showTime ? `<th class="sortable-header" data-sort-key="timeUsedSec" style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Time${getSortIndicator('timeUsedSec')}</th>` : ''}
                ${showWrongs ? `<th class="sortable-header" data-sort-key="wrongs" style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Wrongs${getSortIndicator('wrongs')}</th>` : ''}
                ${showHints ? `<th class="sortable-header" data-sort-key="hints" style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Hints${getSortIndicator('hints')}</th>` : ''}
                <th class="sortable-header" data-sort-key="when" style="padding:1rem 0.8rem;text-align:left;font-weight:700;color:var(--accent)">Date${getSortIndicator('when')}</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `; 
    }, 500);
  }

  function openLeaderboard(){
    if (!leaderboardModal) return;
    leaderboardModal.style.display='flex';
    leaderboardModal.setAttribute('aria-hidden','false');
    
    leaderboardModeFilter = 'all';
    const modeFilterContainer = $id('leaderboardModeFilter');
    if (modeFilterContainer) {
        modeFilterContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
        const allBtn = modeFilterContainer.querySelector('button[data-mode-filter="all"]');
        if (allBtn) allBtn.classList.add('active');
    }

    showGlobalLeaderboard();

    if (clearLbBtn) clearLbBtn.disabled = false;
    if (closeLbBtn) { closeLbBtn.disabled = false; closeLbBtn.focus(); }
    if (untrapModal) untrapModal();
    untrapModal = trapFocus(leaderboardModal);
    const esc = (e)=>{ if (e.key==='Escape') closeLeaderboard(); };
    document.addEventListener('keydown', esc, { once:true });
    leaderboardModal.addEventListener('click', (e)=>{ const card = leaderboardModal.querySelector('.modal-card'); if (e.target === leaderboardModal || (card && !card.contains(e.target))) closeLeaderboard(); }, { once:true });
  }

  function showGlobalLeaderboard() {
    const globalBtn = $id('globalLbBtn');
    if (!leaderboardBody) {
      console.error('leaderboardBody not found');
      return;
    }
    globalBtn.classList.add('active');
    $id('localLbBtn')?.classList.remove('active');
    
    // Hide non-competitive filters for global view
    $id('lbFilterAll').style.display = 'none';
    $id('lbFilterUnlimited').style.display = 'none';
    $id('lbFilterTimer').style.display = 'inline-block';
    $id('lbFilterNormal').style.display = 'inline-block';

    // Default to 'timer' view for global leaderboard
    leaderboardModeFilter = 'timer';
    $id('leaderboardModeFilter').querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
    $id('lbFilterTimer').classList.add('active');

    leaderboardBody.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--muted)"><div class="loading"></div><div style="margin-top:1rem">Loading global scores...</div></div>`;

    const gameDateToFilter = selectedGameDate || getEstDateString();
    console.log(`🏆 Requesting global leaderboard for date: ${gameDateToFilter}`);
    
    window.handleLeaderboardData = function(data) {
      console.log('Leaderboard response received:', data);
      try {
        if (data && data.error) {
          console.error('Leaderboard error:', data.error);
          throw new Error(data.error);
        }
        const scores = data && data.scores ? data.scores : [];
        
        // --- FIX: Auto-sort timed global leaderboard by time ---
        if (leaderboardModeFilter === 'timer') {
          scores.sort((a, b) => (a.timeUsedSec ?? Infinity) - (b.timeUsedSec ?? Infinity));
        }
        // --- END FIX ---

        renderLeaderboard(scores, 'global');
      } catch (error) {
        leaderboardBody.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">Could not load global scores.</div>`;
      }
    };
    
    const script = document.createElement('script');
    script.src = `${_0x3c4d}?action=getLeaderboard&gameDate=${encodeURIComponent(gameDateToFilter)}&callback=handleLeaderboardData&_=${Date.now()}`;
    
    const cleanup = () => {
      if (script.parentNode) document.head.removeChild(script);
    };
    
    script.onerror = () => {
      cleanup();
      leaderboardBody.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">Could not load global scores.</div>`;
    };
    
    script.onload = () => {
      cleanup();
    };
    
    document.head.appendChild(script);
  }

  function showLocalLeaderboard() {
    $id('localLbBtn')?.classList.add('active');
    $id('globalLbBtn')?.classList.remove('active');

    // Show all filters for local view
    $id('lbFilterAll').style.display = 'inline-block';
    $id('lbFilterUnlimited').style.display = 'inline-block';
    $id('lbFilterTimer').style.display = 'inline-block';
    $id('lbFilterNormal').style.display = 'inline-block';

    // Default to 'all' for local view
    leaderboardModeFilter = 'all';
    $id('leaderboardModeFilter').querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
    $id('lbFilterAll').classList.add('active');

    renderLeaderboard(loadLeaderboard(), 'local');
  }

  function closeLeaderboard(){
    if (!leaderboardModal) return;
    leaderboardModal.style.display='none';
    leaderboardModal.setAttribute('aria-hidden','true');
    if (clearLbBtn) clearLbBtn.disabled = true;
    if (closeLbBtn) closeLbBtn.disabled = true;
    if (leaderboardBtn) leaderboardBtn.focus();
    if (untrapModal) { untrapModal(); untrapModal = null; }

     if (gameIsOver) {
      resetToStartScreen();
    } else {
      if (leaderboardBtn) leaderboardBtn.focus();
    }
  }

  function clearLeaderboardConfirmed(){ 
    try{ 
      saveLeaderboard([]); 
      leaderboardBody.innerHTML = `
        <div style="text-align:center;padding:3rem;color:var(--ok)">
          <div style="font-size:3rem;margin-bottom:1rem">✅</div>
          <div style="font-size:1.2rem;font-weight:600">Leaderboard Cleared!</div>
          <div style="margin-top:0.5rem;color:var(--muted)">Ready for new champions.</div>
        </div>
      `;
      setTimeout(() => renderLeaderboard([], 'local'), 2000);
    }catch(err){ 
      alert('Could not clear leaderboard'); 
    } 
  }

  /* Enhanced Clock */
  function msToClock(ms){ const s=Math.max(0,Math.round(ms/1000)); const m=Math.floor(s/60); const r=s%60; return `${m}:${r<10?'0':''}${r}` }
  function startClock(){
    clearInterval(clockInterval);
    if (currentMode !== 'timer') return;
    timeLeft = getTimerDuration(ladderData.length);
    const minutes = Math.floor(timeLeft / 60);
    const seconds = timeLeft % 60;
    if (timer) timer.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    if (timer) timer.classList.remove('blink');
    clockInterval = setInterval(()=>{
      timeLeft--;
      const minutes=Math.floor(timeLeft/60);
      const seconds=timeLeft%60;
      if (timer) timer.textContent = `${minutes}:${seconds<10?'0':''}${seconds}`;
      if (timeLeft<=10 && timer) timer.classList.add('blink');
      if (timeLeft<=0) endGame(false, '⏰ Time\u2019s up! The ladder remains unconquered...');
    },1000);
  }
  function stopClock(){ clearInterval(clockInterval); if (timer) timer.classList.remove('blink'); }

  /* Enhanced game building */
  // Undo system
  function saveUndoState(action, data) {
    undoStack.push({ action, data, timestamp: Date.now() });
    if (undoStack.length > 10) undoStack.shift(); // Keep last 10 actions
    updateUndoButton();
  }
  
  function performUndo() {
    if (undoStack.length === 0) return;
    
    const lastAction = undoStack.pop();
    playSound('undo');
    
    switch(lastAction.action) {
      case 'letter':
        const { stepIndex, letterIndex, oldValue } = lastAction.data;
        const stepDiv = ladder.children[stepIndex];
        if (stepDiv && stepDiv.inputs) {
          const input = stepDiv.inputs[letterIndex];
          if (input) {
            input.value = oldValue || '';
            input.focus();
          }
        }
        break;
    }
    
    updateUndoButton();
    saveGameState();
  }
  
  function updateUndoButton() {
    // Undo button removed, but keep function for compatibility
  }
  
  // Auto-save system
  function saveGameState() {
    if (!ladderData || gameIsOver) return;
    
    const state = {
      currentStep,
      currentIndex,
      incorrectWordGuesses,
      diamondLetters,
      timeLeft,
      currentMode,
      gameStartAt,
      revealedLetters,
      hintsUsed,
      isExpanded,
      ladderData,
      manualFinalWord,
      manualFinalHint,
      timestamp: Date.now()
    };
    
    // Save current input values
    if (ladder) {
      state.inputValues = {};
      for (let i = 0; i < ladder.children.length; i++) {
        const stepDiv = ladder.children[i];
        if (stepDiv && stepDiv.inputs) {
          state.inputValues[i] = stepDiv.inputs.map(inp => inp.value || '');
        }
      }
    }
    
    localStorage.setItem('wordLadderGameState', JSON.stringify(state));
  }
  
  function loadGameState() {
    try {
      const saved = localStorage.getItem('wordLadderGameState');
      if (!saved) return false;
      
      const state = JSON.parse(saved);
      // Only restore if saved within last hour
      if (Date.now() - state.timestamp > 3600000) {
        localStorage.removeItem('wordLadderGameState');
        return false;
      }
      
      return state;
    } catch (e) {
      localStorage.removeItem('wordLadderGameState');
      return false;
    }
  }
  
  function clearGameState() {
    localStorage.removeItem('wordLadderGameState');
  }

  function resetGameState(){
    gameIsOver = false;
    undoStack = [];
    const __drop3 = document.getElementById('calendar-dropdown');
    if (__drop3) { __drop3.classList.remove('show'); __drop3.style.display=''; }
    stopClock();
    isSubmitting = false;    timeLeft=getTimerDuration(ladderData.length); incorrectWordGuesses=0; diamondLetters=[]; secretWord=''; currentStep=0; revealedLetters={}; hintsUsed = 0; isExpanded = false; currentIndex = 1;
    if (finalWordInputContainer) { 
        finalWordInputContainer.innerHTML = '';
        finalWordInputContainer.style.display = 'none';
    }
    if (finalSubmit) finalSubmit.disabled=true;
    if (shuffleBtn) shuffleBtn.disabled=true;
    if (shareBtn) shareBtn.disabled = true;
    if (shareTip) shareTip.style.opacity = 0;
    if (finalHint) finalHint.style.display='none';
    if (popupContainer) popupContainer.innerHTML='';
    if (ladder) ladder.innerHTML='';
    if (wrongGuessesCounter) { wrongGuessesCounter.textContent = `Guesses Remaining: ${maxIncorrectGuesses}`; wrongGuessesCounter.style.color = ''; wrongGuessesCounter.style.animation = ''; }
    if (linksCounter) linksCounter.textContent = `Links Solved: 0/${ladderData.length - 2}`;
    if (progressContainer) progressContainer.style.display = 'none';
    updateProgress();
    const underscoreLen = manualFinalWord ? manualFinalWord.replace(/ /g, '').length : totalDiamondCount();
    const sEl = $id('secretLettersText'); 
    if (sEl) {
      sEl.innerHTML = '';
      sEl.textContent = underscoreString(underscoreLen);
    }
    if (manualFinalWord && finalHint) finalHint.textContent = manualFinalHint || 'A secret word awaits…';
    if (hud) {
      hud.style.display = 'flex';
      if (currentMode === 'timer') {
        if (timer) timer.style.display = 'inline-block';
        if (wrongGuessesCounter) wrongGuessesCounter.style.display = 'none';
      } else if (currentMode === 'normal') {
        if (timer) timer.style.display = 'none';
        if (wrongGuessesCounter) wrongGuessesCounter.style.display = 'block';
      } else { // 'unlimited' mode
        if (timer) timer.style.display = 'none';
        if (wrongGuessesCounter) wrongGuessesCounter.style.display = 'none';
      }
      if (linksCounter) linksCounter.style.display = 'block';
    }
    
    const container = document.getElementById('finalWordContainer');
    if (container) {
      container.style.display='flex';
      container.classList.add('small');
      container.classList.remove('expanded');
      if (finalWordInputContainer) finalWordInputContainer.style.display='none';
      if (finalSubmit) finalSubmit.style.display='none';
      if (shuffleBtn) shuffleBtn.style.display='none';
      if (shareBtn) shareBtn.style.display='none';
      if (finalHint) finalHint.style.display='none';
    }
    
    updateSecretLettersDisplay();
    updateUndoButton();
    clearGameState();
  }

  function buildLadder(){
    if (!ladder) return;
    ladder.innerHTML='';
    const useManual = Boolean(manualFinalWord);
    secretWord = useManual ? manualFinalWord.toUpperCase() : '';
    
    ladderData.forEach((step, index)=>{
      const stepDiv = document.createElement('div'); 
      stepDiv.className='step';
      if (index > 1) stepDiv.classList.add('hidden');
      stepDiv.dataset.stepIndex = index;
      
      const wrapper = document.createElement('div'); 
      wrapper.className='word-hint-submit-wrapper';
      
      const wordContainer = document.createElement('div'); 
      wordContainer.className='word-container';
      
      const inputs = [];
      const diamondIndices = Array.isArray(step.diamondIndex) ? step.diamondIndex : typeof step.diamondIndex === 'number' ? [step.diamondIndex] : [];
      
      for (let i=0;i<step.word.length;i++){
        const input = document.createElement('input');
        input.className='bubble';
        input.setAttribute('maxlength','1');
        input.dataset.index = index;
        input.dataset.letter = i;
        input.disabled = true;
        input.type='text';
        input.setAttribute('autocomplete','off');
        input.setAttribute('autocapitalize','characters');
        input.setAttribute('spellcheck','false');
        input.setAttribute('inputmode','text');
        input.setAttribute('aria-label', `Row ${index + 1}, letter ${i + 1}`);
        
        if (index === 0 || index === ladderData.length - 1) { 
          input.value = step.word[i]; 
          input.disabled = true; 
          input.style.fontWeight = '900';
        }
        else if (i === 0) { 
          input.value = step.word[0]; 
          input.disabled = true; 
        }
        
        if (diamondIndices.includes(i)) {
          input.classList.add('green-diamond'); 
          input.dataset.diamond = 'true';
          if (index === 0) {
            diamondLetters[index] = diamondLetters[index] || [];
            diamondLetters[index].push(step.word[i].toUpperCase());
          }
        }
        inputs.push(input); 
        wordContainer.appendChild(input);
      }

      if (index !== 0 && index !== ladderData.length - 1 && currentMode === 'normal') {
        const submitBtn = document.createElement('button');
        submitBtn.className = 'mobile-submit';
        submitBtn.textContent = 'Submit Word';
        submitBtn.type = 'button';
        submitBtn.addEventListener('click', () => submitWordGuess(index));
        wrapper.appendChild(submitBtn);
      }
      
      wrapper.appendChild(wordContainer);
      stepDiv.appendChild(wrapper);
      
      if (index === 0 || index === ladderData.length - 1) {
        stepDiv.classList.add('gold-rung');
      }

      if (index < ladderData.length - 1) {
        const arrowEl = document.createElement('div'); 
        arrowEl.className = 'down-arrow animate';
        arrowEl.dataset.stepIndex = index;
        
        const nextStep = ladderData[index + 1];
        if (nextStep && nextStep.hint) {
          const hintEl = document.createElement('div');
          hintEl.className = 'arrow-hint';
          
          const hintText = document.createElement('span');
          hintText.textContent = nextStep.hint;
          hintEl.appendChild(hintText);

          const infoIcon = document.createElement('span');
          infoIcon.className = 'info-icon-hint';
          infoIcon.textContent = 'ⓘ';
          hintEl.appendChild(infoIcon);
          
          const tooltip = document.createElement('div');
          tooltip.className = 'hint-tooltip';
          tooltip.textContent = getHintExplanation(nextStep.hint);
          hintEl.appendChild(tooltip);
          
          arrowEl.appendChild(hintEl);
        }
        
        arrowEl.innerHTML += '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 5v14" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M18 11l-6 6-6-6" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
        stepDiv.appendChild(arrowEl);
      }

      ladder.appendChild(stepDiv);
      stepDiv.inputs = inputs;
    });
    
    // Manually collect diamonds from the last word as it's pre-filled
    const lastStepData = ladderData[ladderData.length - 1];
    if (lastStepData && lastStepData.diamondIndex) {
        const lastStepIndex = ladderData.length - 1;
        diamondLetters[lastStepIndex] = diamondLetters[lastStepIndex] || [];
        lastStepData.diamondIndex.forEach(diamondIdx => {
            const letter = lastStepData.word[diamondIdx];
            if (letter) diamondLetters[lastStepIndex].push(letter.toUpperCase());
        });
    }
    
    if (finalHint) finalHint.style.display='none';
    if (finalWordInputContainer) finalWordInputContainer.style.display = 'none';
    if (finalSubmit) finalSubmit.disabled=true;
    if (shuffleBtn) shuffleBtn.disabled=true;
    updateSecretLettersDisplay();
  }

  function updateLinksCounter() {
    if (!linksCounter) return;
    const solved = Math.max(0, currentStep - 1);
    const total = ladderData.length - 2;
    linksCounter.textContent = `Links Solved: ${solved}/${total}`;
  }

  function updateStepVisibility(currentIndex) {
    if (!ladder || isExpanded) return;
    
    // Update visibility
    for (let i = 0; i < ladder.children.length; i++) {
      const stepDiv = ladder.children[i];
      if (!stepDiv) continue;
      
      const isPrevious = i === currentIndex - 1;
      const isCurrent = i === currentIndex;
      const isNext = i === currentIndex + 1;
      
      const shouldShow = isPrevious || isCurrent || isNext;
      
      if (shouldShow) {
        stepDiv.classList.remove('hidden');
      } else {
        stepDiv.classList.add('hidden');
      }
      
      const arrow = stepDiv.querySelector('.down-arrow');
      if (arrow) {
        const hasNextStep = i + 1 < ladder.children.length;
        const nextStepVisible = hasNextStep && (i + 1 === currentIndex - 1 || i + 1 === currentIndex || i + 1 === currentIndex + 1);
        // Show arrow only if current step is visible, has a next step, AND the next step is also visible
        const arrowVisible = shouldShow && hasNextStep && nextStepVisible;
        
        if (arrowVisible) {
          arrow.style.display = 'flex';
        } else {
          arrow.style.display = 'none';
        }
      }
    }
    
    // Center on current word
    setTimeout(() => {
      const currentStepDiv = ladder.children[currentIndex];
      if (currentStepDiv) {
        currentStepDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }, 50);
      
      const existingIndicator = document.querySelector('.continuation-indicator');
      if (existingIndicator) existingIndicator.remove();
      
      const hasMoreWords = currentIndex + 2 < ladderData.length && !isExpanded;
      if (hasMoreWords) {
        const indicator = document.createElement('div');
        indicator.className = 'continuation-indicator';
        indicator.innerHTML = '⋮<br><small style="font-size:0.7rem;opacity:0.7">tap to see all words</small>';
        indicator.style.cssText = `
          text-align: center;
          color: var(--accent);
          font-size: 1.5rem;
          padding: 1rem;
          opacity: 0.8;
          font-weight: 600;
          position: absolute;
          bottom: -2rem;
          left: 50%;
          transform: translateX(-50%);
          z-index: 15;
          cursor: pointer;
          transition: all 0.2s ease;
        `;
        indicator.onclick = () => expandAllWords();
        ladder.appendChild(indicator);
      }
      

      
      // Add scroll up button if there are previous words
      const existingScrollBtn = document.querySelector('.scroll-up-btn');
      if (existingScrollBtn) existingScrollBtn.remove();
      
      if (currentIndex > 1 && !isExpanded) {
        const scrollBtn = document.createElement('button');
        scrollBtn.className = 'scroll-up-btn';
        scrollBtn.innerHTML = '↑';
        scrollBtn.style.cssText = `
          position: absolute;
          top: 50%;
          left: calc(50% + var(--word-line-width)/2 + var(--ladder-rail-offset) + 20px);
          transform: translateY(-50%);
          width: 48px;
          height: 48px;
          border-radius: 50%;
          background: rgba(255,255,255,0.95);
          border: 2px solid var(--accent);
          color: var(--accent);
          font-size: 1.4rem;
          font-weight: 900;
          cursor: pointer;
          z-index: 100;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        `;
        scrollBtn.onclick = () => scrollUp();
        ladder.appendChild(scrollBtn);
      }
      
      // Add scroll down button if we can go forward one word
      const existingScrollDownBtn = document.querySelector('.scroll-down-single-btn');
      if (existingScrollDownBtn) existingScrollDownBtn.remove();
      
      const canGoForwardOne = currentIndex < currentStep && !isExpanded;
      if (canGoForwardOne) {
        const scrollDownBtn = document.createElement('button');
        scrollDownBtn.className = 'scroll-down-single-btn';
        scrollDownBtn.innerHTML = '↓';
        scrollDownBtn.style.cssText = `
          position: absolute;
          top: 50%;
          left: calc(50% - var(--word-line-width)/2 - var(--ladder-rail-offset) - 68px);
          transform: translateY(-50%);
          width: 48px;
          height: 48px;
          border-radius: 50%;
          background: rgba(255,255,255,0.95);
          border: 2px solid var(--accent);
          color: var(--accent);
          font-size: 1.4rem;
          font-weight: 900;
          cursor: pointer;
          z-index: 100;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        `;
        scrollDownBtn.onclick = () => scrollDown();
        ladder.appendChild(scrollDownBtn);
      }
      

      


  }

  function enableWord(index){
    if (!ladder) return;
    currentStep = Math.max(currentStep, index);
    currentIndex = index; // Update current viewing position
    updateProgress();
    updateLinksCounter();
    updateStepVisibility(index);
    
    const stepDiv = ladder.children[index]; 
    if (!stepDiv) return;
    const inputs = stepDiv.inputs;
    
    stepDiv.style.transform = 'scale(1.02)';
    stepDiv.style.transition = 'transform 0.3s ease';
    setTimeout(() => {
      stepDiv.style.transform = '';
    }, 300);
    
    const isLastWord = index === ladderData.length - 1;
    
    inputs.forEach(input=>{
      if (isLastWord) {
        input.disabled = true;
      } else {
        input.disabled=false;
        input.classList.remove('correct','incorrect');
        if (input.dataset.letter==0) input.value = input.value.toUpperCase();
        else input.value='';
        if (input.dataset.letter==0) input.disabled=true;
        if (input.dataset.diamond === 'true') {
          input.classList.add('green-diamond');
        }
      }
    });
    
    if (currentMode === 'unlimited' && !isLastWord) {
      const wrapper = stepDiv.querySelector('.word-hint-submit-wrapper');
      if (wrapper && !wrapper.querySelector('.hint-btn')) {
        const hintBtn = document.createElement('button');
        hintBtn.className = 'btn minor hint-btn';
        hintBtn.textContent = '💡 Hint';
        hintBtn.style.padding = '0.5rem 1rem';
        hintBtn.style.fontSize = '0.9rem';
        hintBtn.style.marginTop = '0.5rem';
        hintBtn.onclick = () => giveHint(index);
        wrapper.appendChild(hintBtn);
      }
    }
    
    if (!isLastWord && inputs.length>1) {
      if (isMobile || isExpanded) {
        stepDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        setTimeout(() => {
          inputs[1].focus();
          if (isMobile) inputs[1].click();
        }, 400);
      } else {
        inputs[1].focus();
      }
    } else if (isLastWord) {
      setTimeout(() => enableFinalInput(), 500);
    }
  }

  function giveHint(index) {
    if (currentMode === 'unlimited') {
        hintsUsed++;
    }
    if (!ladder) return;
    const stepDiv = ladder.children[index];
    const inputs = stepDiv.inputs || [];
    const correctWord = ladderData[index].word.toUpperCase();
    
    let hintGiven = false;
    let hintIndex = -1;

    // Find the first non-disabled input and fill it
    for (let i = 1; i < inputs.length; i++) { // Start from 1 to skip the first letter
       if (!inputs[i].disabled) {
        const inputToHint = inputs[i];
        
        inputToHint.value = correctWord[i];
        
         if (!inputToHint.classList.contains('green-diamond')) {
          inputToHint.style.background = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
          inputToHint.style.borderColor = '#d97706';
          inputToHint.style.color = '#92400e';
        }
        
        inputToHint.disabled = true;

        hintGiven = true;
        hintIndex = i;
        break;
      }
    }

    if (!hintGiven) return;
    const isComplete = inputs.every(inp => inp.disabled || inp.value);
    
    if (isComplete) {
      setTimeout(() => submitWordGuess(index), 200);
    } else {
      // Focus next available input
      for (let i = hintIndex + 1; i < inputs.length; i++) {
        if (!inputs[i].disabled) {
          inputs[i].focus();
          break;
        }
      }
    }
  }

  function collectDiamondsFromInputs(index){
    if (!ladder) return;
    const stepDiv = ladder.children[index];
    const inputs = stepDiv.inputs || [];
    const diamondInputs = inputs.filter(inp=> inp.dataset.diamond === 'true');
    if (!diamondInputs.length) return;
    
    diamondLetters[index] = diamondLetters[index] || [];
    diamondInputs.forEach(inp=>{
      diamondLetters[index].push((inp.value||inp.defaultValue||'').toUpperCase());
      
      const s = inp.value || inp.defaultValue || '';
      if (s){
        const clone = document.createElement('div');
        clone.textContent = s.toUpperCase();
        clone.style.position='absolute';
        const r = inp.getBoundingClientRect();
        clone.style.left = (r.left + window.scrollX) + 'px';
        clone.style.top = (r.top + window.scrollY) + 'px';
        clone.style.width = inp.offsetWidth + 'px';
        clone.style.height = inp.offsetHeight + 'px';
        clone.style.display='flex';
        clone.style.alignItems='center';
        clone.style.justifyContent='center';
        clone.style.borderRadius='50%';
        clone.style.background = 'linear-gradient(135deg, var(--diamond-bg), #5eead4)';
        clone.style.border = '3px solid var(--diamond-br)';
        clone.style.zIndex = 2000;
        clone.style.fontWeight = '800';
        clone.style.fontSize = '1.2rem';
        clone.style.boxShadow = '0 0 20px rgba(15,118,110,0.5)';
        document.body.appendChild(clone);

        for (let i = 0; i < 5; i++) {
          const sparkle = document.createElement('div');
          sparkle.style.position = 'absolute';
          sparkle.style.width = '6px';
          sparkle.style.height = '6px';
          sparkle.style.background = '#fbbf24';
          sparkle.style.borderRadius = '50%';
          sparkle.style.left = (r.left + window.scrollX + Math.random() * r.width) + 'px';
          sparkle.style.top = (r.top + window.scrollY + Math.random() * r.height) + 'px';
          sparkle.style.zIndex = 2001;
          sparkle.style.pointerEvents = 'none';
          document.body.appendChild(sparkle);
          
          sparkle.animate([
            { transform: 'scale(0) rotate(0deg)', opacity: 1 },
            { transform: 'scale(1.5) rotate(180deg)', opacity: 0 }
          ], {
            duration: 600,
            easing: 'ease-out',
            delay: Math.random() * 200
          }).onfinish = () => sparkle.remove();
        }

        const target = $id('secretLettersText'); 
        if (target){
          const tr = target.getBoundingClientRect();
          const dx = (tr.left + tr.width/2) - (r.left + r.width/2);
          const dy = (tr.top + tr.height/2) - (r.top + r.height/2);
          clone.animate(
            [ 
              {transform:'translate(0,0) scale(1)', opacity:1},
              {transform:`translate(${dx}px, ${dy}px) scale(.8)`, opacity:0.2} 
            ],
            {duration:900, easing:'cubic-bezier(.2,.9,.3,1)'}
          ).onfinish = () => { clone.remove(); };
        }
      }
      inp.classList.add('reveal');
      setTimeout(()=> inp.classList.remove('reveal'), 800);
    });
    
    if (!manualFinalWord) { secretWord = diamondLetters.flat().filter(Boolean).join(''); }
    updateSecretLettersDisplay();
  }

  function markRowCorrect(index){
    if (!ladder) return;
    console.log(`✅ markRowCorrect called for step ${index}`);
    
    const stepDiv = ladder.children[index];
    const inputs = stepDiv.inputs || [];
    inputs.forEach((inp, i)=>{
      inp.classList.remove('incorrect'); 
      inp.disabled = true;
      setTimeout(() => {
        inp.classList.add('correct');
        if (inp.dataset.diamond === 'true') {
          inp.classList.add('green-diamond');
        }
      }, i * 50);
    });
    stepDiv.classList.add('gold-rung');
  }

  function giveHint(index) {
    if (currentMode === 'unlimited') {
        hintsUsed++;
    }
    if (!ladder) return;
    const stepDiv = ladder.children[index];
    const inputs = stepDiv.inputs || [];
    const correctWord = ladderData[index].word.toUpperCase();
    
    let hintGiven = false;
    let hintIndex = -1;

    for (let i = 1; i < inputs.length; i++) {
       if (!inputs[i].disabled) {
        const inputToHint = inputs[i];
        
        inputToHint.value = correctWord[i];
        
         if (!inputToHint.classList.contains('green-diamond')) {
          inputToHint.style.background = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
          inputToHint.style.borderColor = '#d97706';
          inputToHint.style.color = '#92400e';
        }
        
        inputToHint.disabled = true;

        hintGiven = true;
        hintIndex = i;
        break;
      }
    }

    if (!hintGiven) return;
    const isComplete = inputs.every(inp => inp.disabled || inp.value);
    
    if (isComplete) {
      setTimeout(() => submitWordGuess(index), 200);
    } else {
      for (let i = hintIndex + 1; i < inputs.length; i++) {
        if (!inputs[i].disabled) {
          inputs[i].focus();
          break;
        }
      }
    }
 }
  function markRowIncorrect(index){
    if (!ladder) return;
    const stepDiv = ladder.children[index];
    const inputs = stepDiv.inputs || [];
    inputs.forEach(inp=> inp.classList.add('incorrect'));
    playSound('incorrect');
    if (stepDiv) { 
      stepDiv.classList.add('shake'); 
      setTimeout(()=> stepDiv.classList.remove('shake'), 500); 
    }
  }

  function submitWordGuess(index) {

  if (!ladder || isSubmitting || gameIsOver) {
    return;
  }
  isSubmitting = true;
  
  const stepDiv = ladder.children[index];
  const inputs = stepDiv.inputs || [];
  const guess = inputs.map(inp => (inp.value||'').toUpperCase()).join('');
  const correctWord = ladderData[index].word.toUpperCase();
  console.log(`Guess: "${guess}", Correct: "${correctWord}"`);
  
  if (guess === correctWord) {
    const hintBtn = stepDiv.querySelector('.hint-btn');
    if (hintBtn) hintBtn.remove();
    
    playSound('correct');
    markRowCorrect(index);
    collectDiamondsFromInputs(index);
    if (index+1 < ladder.children.length) { 
      setTimeout(() => {
        isSubmitting = false;
        enableWord(index+1);
        saveGameState();
      }, 600);
    }
    else { 
      setTimeout(() => {
        isSubmitting = false;
        enableFinalInput();
      }, 600);
    }
  } else {
    incorrectWordGuesses++;
    if (currentMode !== 'unlimited') {
      const remaining = maxIncorrectGuesses - incorrectWordGuesses;
      if (wrongGuessesCounter) {
        wrongGuessesCounter.textContent = `Guesses Remaining: ${remaining}`;
        wrongGuessesCounter.style.animation = 'shake 0.5s ease-in-out';
        wrongGuessesCounter.style.background = '#ffebee';
        setTimeout(() => {
          wrongGuessesCounter.style.animation = '';
          wrongGuessesCounter.style.background = '';
        }, 500);
        
        wrongGuessesCounter.style.color = remaining <= 1 ? 'var(--bad)' : '';
        if (remaining === 1) {
          wrongGuessesCounter.classList.add('pulse');
        } else {
          wrongGuessesCounter.classList.remove('pulse');
        }
      }
    }
    markRowIncorrect(index);
    
    if (currentMode === 'unlimited') {
      const wrapper = stepDiv.querySelector('.word-hint-submit-wrapper');
      if (wrapper && !wrapper.querySelector('.hint-btn')) {
        const hintBtn = document.createElement('button');
        hintBtn.className = 'btn minor hint-btn';
        hintBtn.textContent = '💡 Hint';
        hintBtn.style.padding = '0.5rem 1rem';
        hintBtn.style.fontSize = '0.9rem';
        hintBtn.style.marginTop = '0.5rem';
        hintBtn.onclick = () => giveHint(index);
        wrapper.appendChild(hintBtn);
      }
    }
    
    setTimeout(() => {
      for (let i = 1; i < inputs.length; i++) {
        if (!inputs[i].disabled) {
            inputs[i].value = '';
        }
      }

      if (currentMode === 'normal' && incorrectWordGuesses < maxIncorrectGuesses) {
          const correctWord = ladderData[index].word.toUpperCase();
          
          if (!revealedLetters[index]) revealedLetters[index] = 0;
          
          const positionToReveal = 1 + revealedLetters[index];
          if (positionToReveal < inputs.length) {
            const inputToReveal = inputs[positionToReveal];
            inputToReveal.value = correctWord[positionToReveal];
            if (!inputToReveal.classList.contains('green-diamond')) {
              inputToReveal.style.background = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
              inputToReveal.style.borderColor = '#d97706';
              inputToReveal.style.color = '#92400e';
            }
            inputToReveal.disabled = true;
            revealedLetters[index]++;
          }
      }

      for (let i = 1; i < inputs.length; i++) {
          if (!inputs[i].disabled) {
              inputs[i].focus();
              break;
          }
      }
    }, 600);
    
    if (currentMode === 'normal' && incorrectWordGuesses >= maxIncorrectGuesses) {
      endGame(false, '💥 Too many wrong guesses! The ladder crumbles beneath you...');
    }
    setTimeout(() => {
      isSubmitting = false;
    }, 600);
  }
}

  function enableFinalInput(){
    currentStep = ladderData.length;
    updateProgress();

    if (finalWordInputContainer && secretWord) {
        finalWordInputContainer.innerHTML = '';
        finalWordInputContainer.style.display = 'flex';
        finalWordInputContainer.style.flexWrap = 'wrap';
        finalWordInputContainer.style.justifyContent = 'center';

        const words = secretWord.split(' ');
        words.forEach((word, wordIndex) => {
            const wordWrapper = document.createElement('div');
            wordWrapper.style.display = 'flex';
            wordWrapper.style.gap = 'var(--bubble-gap)';
            wordWrapper.style.marginBottom = 'var(--bubble-gap)';

            word.split('').forEach((char, charIndex) => {
                const input = document.createElement('input');
                input.className = 'bubble final-bubble';
                input.setAttribute('maxlength', '1');
                input.dataset.wordIndex = wordIndex;
                input.dataset.charIndex = charIndex;
                input.type = 'text';
                input.setAttribute('autocomplete', 'off');
                input.setAttribute('autocapitalize', 'characters');
                input.setAttribute('spellcheck', 'false');
                input.setAttribute('aria-label', `Final word, word ${wordIndex + 1}, letter ${charIndex + 1}`);
                wordWrapper.appendChild(input);
            });
            finalWordInputContainer.appendChild(wordWrapper);

            // Add a space element between words, but not after the last one
         if (wordIndex < words.length - 1) {
                const space = document.createElement('div');
                space.className = 'space-separator';
                finalWordInputContainer.appendChild(space);
            }
        });
    }
    
    if (finalSubmit) {
      finalSubmit.disabled=false;
    }
    if (shareBtn) shareBtn.disabled = true;
    if (finalHint) finalHint.textContent = manualFinalWord ? (manualFinalHint || 'Hint: A secret word awaits…') : 'Use the highlighted letters to solve the final word';
    if (finalHint) finalHint.style.display='block';

    if (manualFinalWord && $id('secretLettersText')) {
      if (finalWordDifficulty === 'hard') {
        // Hard mode: scramble all letters together
        scrambledFinalWord = scramble(manualFinalWord.replace(/ /g, '').toUpperCase());
        $id('secretLettersText').innerHTML = scrambledFinalWord.split('').join(' ');
      } else {
        // Easy mode: scramble letters within each word
        scrambledFinalWord = manualFinalWord.toUpperCase().split(' ').map(scramble).join(' ');
        $id('secretLettersText').innerHTML = scrambledFinalWord.split(' ').map(w => w.split('').join(' ')).join('&nbsp;&nbsp;&nbsp;');
      }
      if (shuffleBtn) shuffleBtn.disabled=false;
    }
    
    if (finalWordContainer) {
      finalWordContainer.classList.remove('small');
      finalWordContainer.classList.add('expanded');
    }
    
    if (finalWordInputContainer) finalWordInputContainer.style.display = 'flex';
    if (finalSubmit) finalSubmit.style.display = 'inline-block';
    if (shuffleBtn) shuffleBtn.style.display = 'inline-block';
    if (shareBtn) shareBtn.style.display = 'inline-block';
    
    if (finalWordContainer) {
      finalWordContainer.scrollIntoView({behavior:'smooth', block: isMobile ? 'start' : 'center'});
      setTimeout(()=>{ 
          const firstBubble = finalWordInputContainer.querySelector('.final-bubble');
          if (firstBubble) {
            if (isMobile) {
              setTimeout(() => firstBubble.focus(), 300);
            } else {
              firstBubble.focus();
            }
          }
      }, 100);
    }
  }

  // Sound system with shared audio context
  let audioContext = null;
  let lastSoundTime = 0;
  
  function getAudioContext() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
    return audioContext;
  }
  
  function playSound(type) {
    if (!soundEnabled) return;
    
    try {
      const audioCtx = getAudioContext();
      if (!audioCtx) return;
      
      // Prevent sound overlap issues
      const now = Date.now();
      if (type === 'type' && now - lastSoundTime < 50) return;
      lastSoundTime = now;

      const playNote = (freq, startTime, duration, volume = 0.3) => {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + startTime + duration);

        oscillator.start(audioCtx.currentTime + startTime);
        oscillator.stop(audioCtx.currentTime + startTime + duration);
      };

      switch(type) {
        case 'success':
          playNote(523.25, 0, 0.1);
          playNote(659.25, 0.1, 0.1);
          playNote(783.99, 0.2, 0.15);
          playNote(1046.50, 0.35, 0.2);
          break;
        case 'correct':
          playNote(659.25, 0, 0.1, 0.2);
          playNote(783.99, 0.1, 0.1, 0.2);
          break;
        case 'incorrect':
          playNote(220, 0, 0.2, 0.15);
          break;
        case 'type':
          playNote(800, 0, 0.05, 0.1);
          break;
        case 'undo':
          playNote(400, 0, 0.1, 0.15);
          break;
        case 'button':
          playNote(600, 0, 0.08, 0.12);
          break;
        case 'navigate':
          playNote(500, 0, 0.06, 0.08);
          break;
        case 'modal':
          playNote(450, 0, 0.1, 0.1);
          playNote(550, 0.05, 0.1, 0.1);
          break;
        case 'shuffle':
          playNote(700, 0, 0.05, 0.1);
          playNote(800, 0.05, 0.05, 0.1);
          playNote(900, 0.1, 0.05, 0.1);
          break;
        case 'celebration':
          // Simplified victory melody - fewer overlapping notes, higher volume
          playNote(523.25, 0, 0.4, 0.4);     // C5
          playNote(659.25, 0.4, 0.4, 0.4);   // E5
          playNote(783.99, 0.8, 0.4, 0.4);   // G5
          playNote(1046.50, 1.2, 0.6, 0.5);  // C6 (hold)
          playNote(783.99, 1.8, 0.3, 0.4);   // G5
          playNote(1046.50, 2.1, 0.8, 0.5);  // C6 (final hold)
          break;
      }
    } catch (e) {
      // Silently fail if audio context fails
    }
  }
  
  function playSuccessSound() {
    playSound('success');
  }
  
  function playCelebrationMusic() {
    if (!soundEnabled) return;
    // Ensure audio context is active before playing celebration
    const audioCtx = getAudioContext();
    if (audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        setTimeout(() => playSound('celebration'), 100);
      });
    } else {
      setTimeout(() => playSound('celebration'), 100);
    }
  }

  function updateFinalWordScrambleDisplay() {
    const display = $id('secretLettersText');
    if (!display || !manualFinalWord) return;

    if (finalWordDifficulty === 'hard') {
        const allInputs = finalWordInputContainer.querySelectorAll('.final-bubble');
        const guess = Array.from(allInputs).map(b => b.value.toUpperCase()).join('');
         let tempGuessLetters = guess.split(''); // A mutable array of guessed letters

        if (finalWordDifficulty === 'hard') {
            // Hard mode: check against a single block of scrambled letters
            const newHTML = scrambledFinalWord.split('').map(char => {
                const indexInGuess = tempGuessLetters.indexOf(char);
                if (indexInGuess > -1) {
                    tempGuessLetters.splice(indexInGuess, 1); // Use each guessed letter only once
                    return `<s style="opacity: 0.4; text-decoration-thickness: 2px; text-decoration-color: var(--bad);">${char}</s>`;
                }
                return char;
            }).join(' ');
            display.innerHTML = newHTML;
        } else {
            // Easy mode: check against scrambled letters grouped by word
            const newHTML = scrambledFinalWord.split(' ').map(word => {
                return word.split('').map(char => {
                    const indexInGuess = tempGuessLetters.indexOf(char);
                    if (indexInGuess > -1) {
                        tempGuessLetters.splice(indexInGuess, 1);
                        return `<s style="opacity: 0.4; text-decoration-thickness: 2px; text-decoration-color: var(--bad);">${char}</s>`;
                    }
                    return char;
                }).join(' ');
            }).join('&nbsp;&nbsp;&nbsp;');
            display.innerHTML = newHTML;
        }
    } else { // Easy mode
        const words = secretWord.split(' ');
        const wordInputs = finalWordInputContainer.querySelectorAll('.word-wrapper');
        const scrambledWords = scrambledFinalWord.split(' ');

        const newHTML = words.map((word, i) => {
            const inputs = wordInputs[i].querySelectorAll('.final-bubble');
            const guess = Array.from(inputs).map(b => b.value.toUpperCase()).join('');
            let tempGuessLetters = guess.split('');
            return scrambledWords[i].split('').map(char => {
                const indexInGuess = tempGuessLetters.indexOf(char);
                if (indexInGuess > -1) {
                    tempGuessLetters.splice(indexInGuess, 1);
                    return `<s style="opacity: 0.4; text-decoration-thickness: 2px; text-decoration-color: var(--bad);">${char}</s>`;
                }
                return char;
            }).join(' ');
        }).join('&nbsp;&nbsp;&nbsp;');
        display.innerHTML = newHTML;
    }
  }

  function submitFinalWord(){
    if (isSubmitting || gameIsOver) return;
    isSubmitting = true;

    const finalBubbles = finalWordInputContainer.querySelectorAll('.final-bubble');
    if (!finalBubbles || finalBubbles.length === 0) {
        isSubmitting = false;
        return;
    }
    const guess = Array.from(finalBubbles).map(inp => inp.value.trim().toUpperCase()).join('');
    
    if (guess.length !== secretWord.replace(/ /g, '').length) {
        isSubmitting = false;
        return;
    }
    
    if (guess === secretWord.replace(/ /g, '')) {
        playSuccessSound();
        
        finalBubbles.forEach(bubble => {
            bubble.disabled = true;
        });

        finalBubbles.forEach((bubble, i) => {
            setTimeout(() => {
                bubble.classList.add('reveal-animation');
            }, i * 100);
        });

        const totalAnimationTime = finalBubbles.length * 100 + 500;

        setTimeout(() => {
          if (finalSubmit) finalSubmit.disabled = true;
          if (shareBtn) shareBtn.disabled = false;
          stopClock();
          const timeMsg = currentMode === 'timer' ? ` in ${msToClock((getTimerDuration(ladderData.length) - timeLeft) * 1000)}` : '';
          const wrongsMsg = currentMode === 'normal' && incorrectWordGuesses > 0 ? ` with ${incorrectWordGuesses} wrong guess${incorrectWordGuesses > 1 ? 'es' : ''}` : '';
          
          // Save the score first
      const gameDateForScore = selectedGameDate || getEstDateString();
      const initialTime = getTimerDuration(ladderData.length);
      const timeUsedSec = (currentMode === 'timer') ? (initialTime - timeLeft) : Math.floor((Date.now() - (gameStartAt||Date.now()))/1000);
      
      getPlayerName().then(playerName => {
        const scorePayload = {
            name: playerName,
            mode: currentMode, success: true, timeUsedSec,
            finalWord: secretWord, gameDate: gameDateForScore,
            wrongs: incorrectWordGuesses,
            hints: (currentMode === 'unlimited') ? hintsUsed : null
        };
        saveScore(scorePayload);
        if (!isCustomGame && (!selectedGameDate || selectedGameDate === getEstDateString())) {
          submitGlobalScore(scorePayload);
        }
        
        // Then show the popup
        showPopup(`🎉 Victory! You conquered the ladder${timeMsg}${wrongsMsg}!`, resetToStartScreen, true);
          }, true);
        }, totalAnimationTime);
      
    } else {
      finalBubbles.forEach(bubble => {
          bubble.classList.add('incorrect');
          bubble.style.animation = 'incorrectShake 0.5s ease-out';
      });
      
      setTimeout(() => {
        finalBubbles.forEach(bubble => {
            bubble.value = '';
            bubble.classList.remove('incorrect');
            bubble.style.animation = '';
        });
            updateFinalWordScrambleDisplay();
        const firstBubble = finalWordInputContainer.querySelector('.final-bubble');
        if (firstBubble) firstBubble.focus();
        isSubmitting = false;
      }, 500);
      
      incorrectWordGuesses++;
      
      if (currentMode === 'normal') {
        const remaining = maxIncorrectGuesses - incorrectWordGuesses;
        
        if (wrongGuessesCounter) {
          wrongGuessesCounter.textContent = `Guesses Remaining: ${remaining}`;
          wrongGuessesCounter.style.color = 'var(--bad)';
          wrongGuessesCounter.style.background = 'var(--bad-bg)';
          wrongGuessesCounter.style.animation = 'shake 0.5s ease-in-out';
          setTimeout(() => {
            wrongGuessesCounter.style.color = remaining <= 1 ? 'var(--bad)' : '';
            wrongGuessesCounter.style.background = '';
            wrongGuessesCounter.style.animation = '';
          }, 500);
          
          if (remaining === 1) {
            wrongGuessesCounter.classList.add('pulse');
          } else {
            wrongGuessesCounter.classList.remove('pulse');
          }
        }
        
        // Reveal a letter from the final word as a hint
        if (remaining > 0 && secretWord) {
            const display = $id('secretLettersText');
          if (display) {
            const targetWord = secretWord.toUpperCase();
            const currentLetters = display.textContent.split(' ');
            
            for (let i = 0; i < targetWord.length; i++) {
              if (currentLetters[i] === '_' || currentLetters[i] !== targetWord[i]) {
                currentLetters[i] = targetWord[i];
                display.textContent = currentLetters.join(' ');
                break;
              }
            }
          }
        }
        
        if (remaining <= 0) { 
          finalBubbles.forEach(b => b.disabled = true);
          if (finalSubmit) finalSubmit.disabled = true;
          endGame(false, '💥 Too many wrong guesses! The final word remains a mystery...'); 
        }
      }
    }
    
    setTimeout(() => {
      isSubmitting = false;
    }, 600);
  }

  if (finalWordInputContainer) {
    finalWordInputContainer.addEventListener('input', (e) => {
        const currentInput = e.target;
        if (!currentInput.classList.contains('final-bubble')) return;

        currentInput.value = currentInput.value.toUpperCase().replace(/[^A-Z]/g, '');

        const allInputs = Array.from(finalWordInputContainer.querySelectorAll('.final-bubble'));        const currentIndex = allInputs.indexOf(currentInput);

        if (currentInput.value && currentIndex < allInputs.length - 1) {            allInputs[currentIndex + 1].focus();
        }
        updateFinalWordScrambleDisplay();
    });

    finalWordInputContainer.addEventListener('keydown', (e) => {
        const currentInput = e.target;
        if (!currentInput.classList.contains('final-bubble')) return;

        const allInputs = Array.from(finalWordInputContainer.querySelectorAll('.final-bubble'));        
        const currentIndex = allInputs.indexOf(currentInput);

        if (e.key === 'Enter') {
            e.preventDefault();
            submitFinalWord();
        }
         if (e.key === 'Backspace') {
            if (!currentInput.value && currentIndex > 0) {
                e.preventDefault();
                const prevInput = allInputs[currentIndex - 1];
                if (prevInput) {
                    prevInput.value = '';
                    prevInput.focus();
                    updateFinalWordScrambleDisplay();
                }
            } else {
                setTimeout(updateFinalWordScrambleDisplay, 0);
            }
        }
    });
  }

  /* Enhanced Popup with fixed onClose callback */
  function showPopup(message, onClose, success=false){
    if (!popupContainer) return;
    
    let isPopupClosed = false;
    
    function callOnCloseOnce() {
      if (isPopupClosed) return;
      isPopupClosed = true;
      if (onClose) onClose();
    }
    
    const actions = `
      <div style="margin-top:1.5rem; display:flex; gap:1rem; justify-content:center; flex-wrap:wrap;">
        ${success ? '<button id="popupShare" class="btn secondary" type="button">📤 Share Victory</button>' : ''}
        <button id="popupLeaderboard" class="btn minor" type="button">🏆 View Scores</button>
        <button id="popupHome" class="btn primary" type="button">🏠 Back to Menu</button>
      </div>
    `;
    
    popupContainer.innerHTML = `
      <div class="popup-overlay">
        <div class="popup" role="dialog" aria-live="polite" aria-label="Game result">
          <div style="font-size:1.3rem;font-weight:700;margin-bottom:1rem;line-height:1.4">${message}</div>
          ${actions}
        </div>
        ${ success ? '<div class="confetti" aria-hidden="true"></div>' : '' }
      </div>
    `;

    const overlay = popupContainer.querySelector('.popup-overlay');
    const dialog = popupContainer.querySelector('.popup');

    if (success) {
      playCelebrationMusic();
      const confContainer = popupContainer.querySelector('.confetti');
      if (confContainer) {
        const colors = ['#fbbf24', '#f59e0b', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899'];
        for (let i=0;i<36;i++){
          const s=document.createElement('span');
          s.style.left = Math.random()*100 + '%';
          s.style.background = colors[Math.floor(Math.random() * colors.length)];
          s.style.position='absolute';
          s.style.width='12px';
          s.style.height='16px';
          s.style.animation = 'confettiFall 1500ms linear forwards';
          s.style.animationDelay = (Math.random()*600) + 'ms';
          confContainer.appendChild(s);
        }
        setTimeout(()=>{ if (confContainer) confContainer.remove(); }, 2200);
      }
    }

    if (popupAutoCloseTimeout) { clearTimeout(popupAutoCloseTimeout); popupAutoCloseTimeout = null; }
    popupAutoCloseTimeout = setTimeout(()=>{ closePopup(); }, 6000);

    const escHandler = (e) => { if (e.key === 'Escape') closePopup(); };
    document.addEventListener('keydown', escHandler);

    function closePopup(){
      if (popupAutoCloseTimeout) { clearTimeout(popupAutoCloseTimeout); popupAutoCloseTimeout = null; }
      popupContainer.innerHTML='';
      document.removeEventListener('keydown', escHandler);
      callOnCloseOnce();
    }

    if (overlay){
      overlay.addEventListener('click', (e)=>{
        if (!dialog || !dialog.contains(e.target)) closePopup();
      });
    }

    const popLeaderboard = popupContainer.querySelector('#popupLeaderboard');
    const popShare = popupContainer.querySelector('#popupShare');
    const popHome = popupContainer.querySelector('#popupHome');

    if (popHome){
      popHome.disabled = false;
      popHome.focus();
      popHome.addEventListener('click', ()=>{
        if (popupAutoCloseTimeout){ clearTimeout(popupAutoCloseTimeout); popupAutoCloseTimeout = null; }
        resetToStartScreen(); // Directly go to the main menu
        callOnCloseOnce();
      });
    }
    if (popLeaderboard){
      popLeaderboard.addEventListener('click', ()=>{
        if (popupAutoCloseTimeout){ clearTimeout(popupAutoCloseTimeout); popupAutoCloseTimeout = null; }
        popupContainer.innerHTML='';
        openLeaderboard();
        callOnCloseOnce();
      });
    }
    if (popShare && popShare.addEventListener){
      popShare.addEventListener('click', async ()=>{
        try{ 
          await navigator.clipboard.writeText(buildShareText()); 
          const btn = popShare;
          const originalText = btn.textContent;
          btn.textContent = '✅ Copied!';
          btn.style.background = 'linear-gradient(135deg, var(--ok), #16a34a)';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
          }, 1500);
        }catch{ 
          alert('Could not copy to clipboard'); 
        }
      });
    }
  }

  function disableAllInputs(){
    const keep = ['infoButton','clearLbBtn','closeLbBtn','popupReplay','popupLeaderboard','popupShare','popupHome','leaderboardBtn','closeInfo','closeInfoX', 'calendar-icon', 'exitButton', 'globalLbBtn', 'localLbBtn', 'lbFilterAll', 'lbFilterTimer', 'lbFilterNormal', 'lbFilterUnlimited', 'themeToggle'];
    document.querySelectorAll('input').forEach(i=>i.disabled=true);
    document.querySelectorAll('button').forEach(b=>{ if (!keep.includes(b.id) && !b.classList.contains('calendar-nav')) b.disabled=true; });
  }

  function endGame(success, message){ 
    gameIsOver = true;
    stopClock(); 
    disableAllInputs(); 
    updateProgress();
    showPopup(message, ()=>{ resetToStartScreen(); }, success); 
  }

   // NEW variables for info popup pagination
  let currentInfoPage = 1;
  const totalInfoPages = 4;

  // NEW function to handle info popup pagination
  function showInfoPage(pageNumber) {
    currentInfoPage = pageNumber;

    // Hide all pages
    for (let i = 1; i <= totalInfoPages; i++) {
      const page = $id(`infoPage${i}`);
      if (page) page.style.display = 'none';
    }

    // Show the current page
    const currentPageElement = $id(`infoPage${currentInfoPage}`);
    if (currentPageElement) currentPageElement.style.display = 'block';

    // Update navigation controls
    const backBtn = $id('infoBackBtn');
    const nextBtn = $id('infoNextBtn');
    const indicator = $id('infoPageIndicator');

    if (backBtn) {
      backBtn.style.visibility = (currentInfoPage > 1) ? 'visible' : 'hidden';
    }

    if (nextBtn) {
      if (currentInfoPage === totalInfoPages) {
        nextBtn.textContent = 'Let\'s Play! 🚀';
      } else {
        nextBtn.textContent = 'Next →';
      }
    }
    
    if (indicator) {
        indicator.textContent = `${currentInfoPage} / ${totalInfoPages}`;
    }

    // Handle the animation for page 3
    if (currentInfoPage === 3) {
      startInfoDemoLoop();
    } else {
      stopInfoDemo();
    }
  }

  // REVISED openInfo function
  function openInfo() {
    if (!infoPopup) return;
    infoPopup.style.display = 'flex';
    infoPopup.setAttribute('aria-hidden', 'false');

    // Reset to the first page every time the modal is opened
    showInfoPage(1);

    // NEW: Populate tooltips on info page 2
    const infoHints = infoPopup.querySelectorAll('#infoPage2 .arrow-hint');
    infoHints.forEach(hintEl => {
      const hintKey = hintEl.dataset.hint;
      const tooltip = hintEl.querySelector('.hint-tooltip');
      if (hintKey && tooltip) tooltip.textContent = getHintExplanation(hintKey);
    });
    if (untrapModal) untrapModal();
    untrapModal = trapFocus(infoPopup);
    const esc = (e) => {
      if (e.key === 'Escape') closeInfoModal();
    };
    document.addEventListener('keydown', esc, { once: true });
    infoPopup.addEventListener('click', (e) => {
      const card = infoPopup.querySelector('.modal-card');
      if (e.target === infoPopup || (card && !card.contains(e.target))) closeInfoModal();
    }, { once: true });
  }

  // REVISED closeInfoModal function
  function closeInfoModal(){
    if (!infoPopup) return;
    infoPopup.style.display='none';
    infoPopup.setAttribute('aria-hidden','true');
    stopInfoDemo(); // Make sure demo stops when closing
    if (untrapModal) { untrapModal(); untrapModal = null; }
    if (infoButton) {
      infoButton.disabled = false;
      infoButton.focus();
    }
  }

  // Place these new event listeners with your other listeners
  const infoNextBtn = $id('infoNextBtn');
  const infoBackBtn = $id('infoBackBtn');
  
  if (infoNextBtn) {
    infoNextBtn.addEventListener('click', () => {
      playSound('button');
      if (currentInfoPage < totalInfoPages) {
        showInfoPage(currentInfoPage + 1);
      } else {
        closeInfoModal();
      }
    });
  }

  if (infoBackBtn) {
    infoBackBtn.addEventListener('click', () => {
      playSound('button');
      if (currentInfoPage > 1) {
        showInfoPage(currentInfoPage - 1);
      }
    });
  }

  /* Enhanced Mode / Start */
    function handleModeButtonClick(mode, btn) {
    // Prevent starting if data isn't loaded yet
    if (!ladderData || ladderData.length === 0) {
      console.warn('Mode button clicked before game data loaded');
      alert('⚠️ Game data is still loading. Please wait a moment and try again.');
      return;
    }
    
    // Additional validation to ensure data quality
    const invalidWords = ladderData.filter(word => !word.word || typeof word.word !== 'string' || word.word.length === 0);
    if (invalidWords.length > 0) {
      console.error('Invalid word data detected:', invalidWords);
      alert('⚠️ Game data is corrupted. Please refresh the page.');
      return;
    }
    
    currentMode = mode;
    showButtonLoading(btn);
    if (timerModeBtn && timerModeBtn !== btn) timerModeBtn.disabled = true;
    if (normalModeBtn && normalModeBtn !== btn) normalModeBtn.disabled = true;
    if (unlimitedModeBtn && unlimitedModeBtn !== btn) unlimitedModeBtn.disabled = true;
    if (leaderboardBtn) leaderboardBtn.disabled = true;
    setTimeout(() => startGame(), 50);
  }
  
   if (timerModeBtn) {
    timerModeBtn.addEventListener('click', () => { playSound('button'); handleModeButtonClick('timer', timerModeBtn); });
  }

   if (normalModeBtn) {
    normalModeBtn.addEventListener('click', () => { playSound('button'); handleModeButtonClick('normal', normalModeBtn); });
  }

  if (unlimitedModeBtn) {
    unlimitedModeBtn.addEventListener('click', () => { playSound('button'); handleModeButtonClick('unlimited', unlimitedModeBtn); });
  }

  function showGamePreview() {
    const firstWord = ladderData[0].word;
    const lastWord = ladderData[ladderData.length - 1].word;
    const wordCount = ladderData.length;
    
    const overlay = document.createElement('div');
    overlay.className = 'game-preview-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(var(--accent-rgb), 0.1), rgba(var(--accent-rgb), 0.05));
      backdrop-filter: blur(12px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    `;
    
    overlay.innerHTML = `
      <div class="game-preview-card" style="
        background: var(--panel);
        border-radius: 20px;
        padding: 2.5rem;
        max-width: 400px;
        width: 90%;
        text-align: center;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        border: 1px solid var(--border);
        transform: translateY(20px);
        transition: transform 0.3s ease;
      ">
        <div style="margin-bottom: 2rem;">
          <div style="font-size: 3rem; margin-bottom: 1rem;">🪜</div>
          <h2 style="margin: 0 0 0.5rem; color: var(--accent); font-size: 1.8rem; font-weight: 700;">Ready to Climb?</h2>
          <p style="color: var(--muted); font-size: 1.1rem; margin: 0;">Connect the word</p>
        </div>
        
        <div class="preview-ladder" style="
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 1rem;
          margin: 2rem 0;
          padding: 1.5rem;
          background: var(--bg-primary);
          border-radius: 15px;
          border: 2px dashed var(--border);
        ">
          <div class="preview-word" style="display: flex; gap: 4px;">
            ${firstWord.split('').map(letter => `<div class="preview-bubble" style="
              background: linear-gradient(135deg, #4ade80, #22c55e);
              color: white;
              width: 32px;
              height: 32px;
              border-radius: 8px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: 600;
              font-size: 1rem;
              box-shadow: 0 2px 8px rgba(74, 222, 128, 0.3);
            ">${letter}</div>`).join('')}
          </div>
          
          <div style="
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            color: var(--muted);
            font-size: 1rem;
            font-weight: 500;
          ">
            <div style="font-size: 1.5rem; opacity: 0.6;">⋮</div>
            <span>to</span>
            <div style="font-size: 1.5rem; opacity: 0.6;">⋮</div>
          </div>
          
          <div class="preview-word" style="display: flex; gap: 4px;">
            ${lastWord.split('').map(letter => `<div class="preview-bubble" style="
              background: linear-gradient(135deg, #4ade80, #22c55e);
              color: white;
              width: 32px;
              height: 32px;
              border-radius: 8px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-weight: 600;
              font-size: 1rem;
              box-shadow: 0 2px 8px rgba(74, 222, 128, 0.3);
            ">${letter}</div>`).join('')}
          </div>
          
          <p style="
            color: var(--accent);
            margin: 1rem 0 0;
            font-size: 0.95rem;
            font-weight: 600;
            background: var(--bg-secondary);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            border: 1px solid var(--border);
          ">in ${wordCount} steps</p>
        </div>
        
        <button id="startGameBtn" class="btn primary" style="
          font-size: 1.2rem;
          padding: 1rem 2rem;
          border-radius: 12px;
          font-weight: 600;
          background: linear-gradient(135deg, var(--accent), var(--accent-dark));
          border: none;
          color: white;
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(var(--accent-rgb), 0.3);
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(var(--accent-rgb), 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(var(--accent-rgb), 0.3)'">
          🪜 Start Climbing
        </button>
      </div>
    `;
    
    document.body.appendChild(overlay);
    
    // Animate in immediately
    overlay.style.opacity = '1';
    const card = overlay.querySelector('.game-preview-card');
    if (card) card.style.transform = 'translateY(0)';
    
    const startBtn = overlay.querySelector('#startGameBtn');
    const startGame = () => {
      overlay.style.opacity = '0';
      const card = overlay.querySelector('.game-preview-card');
      if (card) card.style.transform = 'translateY(-20px)';
      setTimeout(() => {
        overlay.remove();
        actuallyStartGame();
      }, 300);
    };
    
    startBtn.onclick = startGame;
    
    // Add Enter key support
    const handleKeyPress = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        startGame();
      }
    };
    document.addEventListener('keydown', handleKeyPress);
    
    // Clean up event listener when overlay is removed
    const originalRemove = overlay.remove;
    overlay.remove = function() {
      document.removeEventListener('keydown', handleKeyPress);
      originalRemove.call(this);
    };
  }
  
  function startGame(){
    // Validate game data before starting
    if (!ladderData || ladderData.length === 0) {
      console.error('Attempted to start game with no ladder data');
      alert('⚠️ Game data is not available. Please wait for loading to complete or refresh the page.');
      // Reset buttons to loading state
      showButtonLoading(timerModeBtn);
      showButtonLoading(normalModeBtn);
      showButtonLoading(unlimitedModeBtn);
      return;
    }
    
    setupGameUI();
  }
  
  function setupGameUI(){
    // Show preview overlay immediately to prevent flash
    showGamePreview();
    
    // Additional validation for data integrity
    const invalidWords = ladderData.filter(word => !word.word || typeof word.word !== 'string' || word.word.length === 0);
    if (invalidWords.length > 0) {
      alert('⚠️ Game data is corrupted. Please refresh the page.');
      resetToStartScreen();
      return;
    }
    
    if (typeof leaderboardBtn !== 'undefined' && leaderboardBtn) leaderboardBtn.disabled = false;
    
    if (hero) {
      hero.style.display='none';
    }
    if (currentMode === 'unlimited') {
      if (hud) hud.style.display='none';
    } else {
      if (hud) hud.style.display='flex';
    }
    if (gamePanel) {
      gamePanel.style.display='block';
    }
    if (progressContainer) progressContainer.style.display='block';
    if ($id('calendar-icon')) $id('calendar-icon').style.display = 'none';
    const __drop = $id('calendar-dropdown');
    if (__drop) { __drop.classList.remove('show'); __drop.style.display = ''; }
    if (leaderboardBtn) leaderboardBtn.disabled = false;

    resetGameState();
    gameStartAt = Date.now();
    setMaxLettersCSSVar();
    buildLadder();
    
    if (gamePanel) gamePanel.style.display='block';
    if (ladder) ladder.style.display='flex';
    if (finalWordContainer) {
      finalWordContainer.style.display='flex';
      finalWordContainer.style.position='sticky';
      finalWordContainer.style.bottom='0';
      finalWordContainer.classList.add('small');
      finalWordContainer.classList.remove('expanded');
      if (finalWordInputContainer) finalWordInputContainer.style.display='none';
      if (finalSubmit) finalSubmit.style.display='none';
      if (shuffleBtn) shuffleBtn.style.display='none';
      if (shareBtn) shareBtn.style.display='none';
      if (finalHint) finalHint.style.display='none';
    }
  
    if (exitButton) {
      exitButton.style.display='flex';
      exitButton.disabled = false;
    }
    
    // Make game panel immediately visible
    if (gamePanel) {
      gamePanel.style.opacity = '1';
      gamePanel.style.transform = 'translateY(0)';
    }

  }
  
  function actuallyStartGame(){
    // NEW: Ensure the preview overlay is removed from the DOM
    const previewOverlay = document.querySelector('.game-preview-overlay');
    if (previewOverlay) {
      previewOverlay.remove();
    }
    gameIsOver = false; // Game is now officially in progress
    enableWord(1);
    startClock();
    
    setTimeout(()=>{
      if (!ladder) return;
      const firstInput = ladder.querySelector('.step:nth-child(2) input:not([disabled])');
      if (firstInput) {
        if (isMobile) {
          firstInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
          setTimeout(() => firstInput.focus(), 300);
        } else {
          firstInput.focus();
        }
      }
    }, 150);
  }

  function expandAllWords() {
    if (!ladder) return;
    isExpanded = true;
    for (let i = 0; i < ladder.children.length; i++) {
      const stepDiv = ladder.children[i];
      if (stepDiv && stepDiv.classList.contains('step')) {
        stepDiv.classList.remove('hidden');
        const arrow = stepDiv.querySelector('.down-arrow');
        if (arrow) arrow.style.display = 'flex';
      }
    }
    const indicator = document.querySelector('.continuation-indicator');
    if (indicator) indicator.remove();
    
    // Center on current word and refocus
    setTimeout(() => {
      const currentStepDiv = ladder.children[currentStep];
      if (currentStepDiv) {
        currentStepDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Find the first empty input in the current step
        const nextInput = currentStepDiv.querySelector('input:not([disabled]):not([readonly]):not([value])');
        if (nextInput) {
          nextInput.focus();
        } else {
          // Look for any input without a value
          const emptyInput = currentStepDiv.querySelector('input:not([disabled])');
          if (emptyInput && !emptyInput.value) {
            emptyInput.focus();
          }
        }
      }
    }, 100);
  }
  
  function scrollUp() {
    if (isExpanded) {
      const firstStep = document.querySelector('.step');
      if (firstStep) {
        firstStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    } else {
      // In 3-word view, go back one word
      currentIndex = Math.max(1, currentIndex - 1);
      updateStepVisibility(currentIndex);
      setTimeout(() => {
        const targetStep = ladder.children[currentIndex];
        if (targetStep) {
          targetStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Focus on next available input
          const nextInput = targetStep.querySelector('input:not([disabled]):not([value])');
          if (nextInput) {
            nextInput.focus();
          }
        }
      }, 100);
    }
  }
  
  function scrollDown() {
    if (!isExpanded) {
      // In 3-word view, go forward one word
      currentIndex = Math.min(currentStep, currentIndex + 1);
      updateStepVisibility(currentIndex);
      setTimeout(() => {
        const targetStep = ladder.children[currentIndex];
        if (targetStep) {
          targetStep.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Focus on next available input
          const nextInput = targetStep.querySelector('input:not([disabled]):not([value])');
          if (nextInput) {
            nextInput.focus();
          }
        }
      }, 100);
    }
  }
  
  function resetToStartScreen() {
    console.log('🔄 Resetting to start screen...');
     gameIsOver = false;
     stopClock();
     incorrectWordGuesses = 0;
     currentStep = 0;
     selectedGameDate = null;
     isCustomGame = false;
     
     const existingScrollBtn = document.querySelector('.scroll-to-top-btn');
     if (existingScrollBtn) existingScrollBtn.remove();
 
     if (hero) hero.style.display='block';
     if (hud) hud.style.display='none';
     if (gamePanel) gamePanel.style.display='none';
     if (progressContainer) progressContainer.style.display='none';
     if (ladder) ladder.style.display='none';
     if (finalWordContainer) finalWordContainer.style.display='none';
     if (popupContainer) popupContainer.innerHTML='';
     if (exitButton) exitButton.style.display='none';
     const existingScrollBtn2 = document.querySelector('.scroll-to-top-btn');
     if (existingScrollBtn2) existingScrollBtn2.remove();
     document.activeElement && document.activeElement.blur();
     
     // Scroll to top of page
     window.scrollTo({top: 0, behavior: 'smooth'});
     
     clearGameState();
 
     // Reset button HTML and show loading state until data is confirmed
     if (timerModeBtn) {
       timerModeBtn.innerHTML = '<span class="btn-content" style="display:none">⚡ Timed Challenge<small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">Race against the clock</small></span><span class="btn-loading" style="display:block"><div class="loading"></div> Loading...</span>';
       timerModeBtn.disabled = true;
     }
     if (normalModeBtn) {
       normalModeBtn.innerHTML = '<span class="btn-content" style="display:none">🎯 Precision Mode<small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">3 strikes and you\'re out</small></span><span class="btn-loading" style="display:block"><div class="loading"></div> Loading...</span>';
       normalModeBtn.disabled = true;
     }
     if (unlimitedModeBtn) {
       unlimitedModeBtn.innerHTML = '<span class="btn-content" style="display:none">🔄 Unlimited Mode<small style="display:block;font-size:0.9rem;opacity:0.8;margin-top:0.3rem">Practice with hints</small></span><span class="btn-loading" style="display:block"><div class="loading"></div> Loading...</span>';
       unlimitedModeBtn.disabled = true;
     }
     if (leaderboardBtn) leaderboardBtn.disabled = false;
     if ($id('leaderboardIconBtn')) $id('leaderboardIconBtn').disabled = false;
     if (infoButton) infoButton.disabled = false;
    if (settingsButton) settingsButton.disabled = false;
    if (themeToggle) themeToggle.disabled = false;
     const calendarBtn = $id('calendar-icon');
     if (calendarBtn) { 
       calendarBtn.style.display = 'flex'; 
       calendarBtn.disabled = false; 
       const __drop2 = $id('calendar-dropdown');
      if (__drop2) { __drop2.classList.remove('show'); __drop2.style.display = ''; }
     }
 
     const subtitle = $id('hero').querySelector('.subtitle');
     if (subtitle) {
         if (selectedGameDate) {
             selectGameDate(selectedGameDate, true);
         } else {
             subtitle.innerHTML = `💎 Climb • Collect • Conquer 💎`;
             // Clear any existing data before loading
             ladderData = [];
             manualFinalWord = '';
             manualFinalHint = '';
             loadTodaysGame();
         }
     }
     
     renderCalendar();
     updateStreakAndStats();
  }

  function buildShareText(){
    let modeTxt = 'Game';
    if (currentMode === 'timer') modeTxt = '⚡ Timed';
    else if (currentMode === 'normal') modeTxt = '🎯 Precision';
    else if (currentMode === 'unlimited') modeTxt = '🔄 Unlimited';

    const initialTime = getTimerDuration(ladderData.length);
    const used = (currentMode === 'timer')
      ? ` in ${msToClock((initialTime - timeLeft) * 1000)}`
      : ` in ${msToClock(Math.max(0, Math.floor((Date.now() - (gameStartAt||Date.now()))/1000)) * 1000)}`;
    const wrongs = currentMode === 'normal' ? ` with ${incorrectWordGuesses} wrong guess${incorrectWordGuesses !== 1 ? 'es' : ''}` : '';
    const final = (secretWord || '(secret)');
    const diamonds = $id('secretLettersText') ? $id('secretLettersText').textContent.replace(/\s+/g, '') : '';
    return [
      '🪜 I just conquered The WordPlay Ladder!',
      `${modeTxt} Mode${used}${wrongs}`,
      `💎 Final Word: ${final}`,
      `🧩 From clues: ${diamonds}`,
      '',
      '🎮 Play at: ' + window.location.href
    ].join('\n');
  }

  // Global keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Don't interfere with input fields
    if (e.target.tagName === 'INPUT' && !e.ctrlKey && !e.metaKey) return;
    
    switch(e.key) {
      case 'Escape':
        if (settingsModal && settingsModal.style.display === 'flex') {
          closeSettingsModal();
        } else if (infoPopup && infoPopup.style.display === 'flex') {
          closeInfoModal();
        } else if (leaderboardModal && leaderboardModal.style.display === 'flex') {
          closeLeaderboard();
        } else if (shortcutsModal && shortcutsModal.style.display === 'flex') {
          closeShortcutsModal();
        } else if (gamePanel && gamePanel.style.display !== 'none') {
          e.preventDefault(); // Prevent browser's default "leave" prompt
          exitButton.click(); // Simulate a click on our custom exit button
        }
        break;
      case 'z':
      case 'Z':
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
          e.preventDefault();
          performUndo();
        }
        break;
      case '?':
        if (!e.ctrlKey && !e.metaKey && !e.shiftKey) openShortcutsModal(); break;
      case 'Enter':
        if (e.target.classList.contains('bubble')) {
          e.preventDefault();
          const index = parseInt(e.target.dataset.index);
          if (!isNaN(index)) submitWordGuess(index);
        }
        break;
      case 'ArrowUp':
        if (gamePanel && gamePanel.style.display !== 'none') {
          e.preventDefault();
          playSound('navigate');
          scrollUp();
        }
        break;
      case 'ArrowDown':
        if (gamePanel && gamePanel.style.display !== 'none') {
          e.preventDefault();
          playSound('navigate');
          scrollDown();
        }
        break;
    }
  });
  
  // Sound toggle
  function toggleSound() {
    soundEnabled = !soundEnabled;
    localStorage.setItem('wordLadderSound', soundEnabled.toString());
    updateAllSoundUI(); // <-- Changed from updateSoundButton
    if (soundEnabled) {
      getAudioContext();
      setTimeout(() => playSound('type'), 100);
    }
  }

   // REVISED function to update ALL sound-related UI elements
  function updateAllSoundUI() {
    // Main button in the corner (code safely does nothing if element is removed)
    if (soundToggle) {
      soundToggle.textContent = soundEnabled ? '🔊' : '🔇';
      soundToggle.classList.toggle('muted', !soundEnabled);
    }
    // Toggle switch in the Settings modal
    if (soundToggleSwitch) {
        // Rebuild the button's inner HTML to prevent text duplication bugs
        const icon = soundEnabled ? '🔊' : '🔇';
        const text = soundEnabled ? 'On' : 'Off';
        soundToggleSwitch.innerHTML = `<span class="toggle-icon">${icon}</span> ${text}`;
        
        soundToggleSwitch.classList.toggle('active', soundEnabled);
    }
  }
  
  function updateSoundButton() {
    if (soundToggle) {
      soundToggle.textContent = soundEnabled ? '🔊' : '🔇';
      soundToggle.classList.toggle('muted', !soundEnabled);
    }
  }

  // --- Event Listeners ---
  if (soundToggleSwitch) soundToggleSwitch.addEventListener('click', () => { playSound('button'); toggleSound(); });
  if (infoButton) infoButton.addEventListener('click', () => { 
    playSound('modal'); 
    openInfo(); 
  });

  // NEW: Custom Confirm Function
  function customConfirm(title, message) {
    return new Promise(resolve => {
      const modal = $id('customConfirmModal');
      $id('confirmTitle').textContent = title;
      $id('confirmMessage').textContent = message;
      const okBtn = $id('confirmOkBtn');
      const cancelBtn = $id('confirmCancelBtn');
      let untrap;

      const close = (result) => {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        if (untrap) untrap();
        resolve(result);
      };

      okBtn.onclick = () => close(true);
      cancelBtn.onclick = () => close(false);
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      untrap = trapFocus(modal);
      okBtn.focus();
    });
  }

  if (exitButton) exitButton.addEventListener('click', () => {
    console.log('Exit button clicked. Game state:', { gameIsOver });
    playSound('button');
    // Close any active preview overlay
    const previewOverlay = document.querySelector('.game-preview-overlay');
    if (previewOverlay) {
      console.log('Preview overlay is active, exiting without confirm.');
      previewOverlay.remove();
      resetToStartScreen();
      return;
    }
    
    customConfirm('Exit to Menu?', 'Your current game progress will be lost.').then(confirmed => {
      if (confirmed) {
        console.log('Exit confirmed.');
        resetToStartScreen();
      } else {
        // If cancelled, refocus on the current word's next available input
        const currentStepDiv = ladder.children[currentStep];
        if (currentStepDiv && currentStepDiv.inputs) {
          const firstEmptyInput = Array.from(currentStepDiv.inputs).find(inp => !inp.disabled && !inp.value);
          if (firstEmptyInput) firstEmptyInput.focus();
          else if (currentStepDiv.inputs[1]) currentStepDiv.inputs[1].focus();
        }
      }
    });
  });
    const globalLbBtn = $id('globalLbBtn');
  const localLbBtn = $id('localLbBtn');
  if (globalLbBtn) globalLbBtn.addEventListener('click', showGlobalLeaderboard);
  if (localLbBtn) localLbBtn.addEventListener('click', showLocalLeaderboard);

  const leaderboardIconBtn = $id('leaderboardIconBtn');
  if (leaderboardIconBtn) leaderboardIconBtn.addEventListener('click', () => {
    if (!leaderboardIconBtn.disabled) {
      playSound('modal');
      openLeaderboard();
    }
  });
  if (closeInfo) closeInfo.addEventListener('click', () => { playSound('button'); closeInfoModal(); });
  if (closeInfoX) closeInfoX.addEventListener('click', () => { playSound('button'); closeInfoModal(); });
  if (leaderboardBtn) leaderboardBtn.addEventListener('click', () => { playSound('modal'); openLeaderboard(); });
  if (closeLbBtn) closeLbBtn.addEventListener('click', () => { playSound('button'); closeLeaderboard(); });
  if (clearLbBtn) {
    clearLbBtn.addEventListener('click', () => {
      if (confirm('🗑️ Clear all local leaderboard entries?\n\nThis cannot be undone!')) {
        clearLeaderboardConfirmed();
      }
    });
  }
  const modeFilterContainer = $id('leaderboardModeFilter');
  if (modeFilterContainer) {
      modeFilterContainer.addEventListener('click', (e) => {
          const button = e.target.closest('button[data-mode-filter]');
          if (!button) return;

          leaderboardModeFilter = button.dataset.modeFilter;

          modeFilterContainer.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');

          renderLeaderboard(null, $id('globalLbBtn').classList.contains('active') ? 'global' : 'local');
      });
  }

  if (leaderboardBody) {
    leaderboardBody.addEventListener('click', (e) => {
        const header = e.target.closest('.sortable-header');
        if (!header) return;

        const sortKey = header.dataset.sortKey;
        if (!sortKey) return;

        if (leaderboardSortState.key === sortKey) {
            leaderboardSortState.order = leaderboardSortState.order === 'asc' ? 'desc' : 'asc';
        } else {
            leaderboardSortState.key = sortKey;
            leaderboardSortState.key = sortKey;
            leaderboardSortState.order = 'asc';
        }

        const listToSort = [...currentLeaderboardData];
        listToSort.sort((a, b) => {
            const order = leaderboardSortState.order === 'asc' ? 1 : -1;
            const isNumeric = ['timeUsedSec', 'wrongs', 'hints'].includes(sortKey);
            
            let valA = a[sortKey];
            let valB = b[sortKey];

            if (isNumeric) {
                valA = valA ?? Infinity;
                valB = valB ?? Infinity;
            } else {
                valA = String(valA ?? '').toLowerCase();
                valB = String(valB ?? '').toLowerCase();
            }

            if (valA < valB) return -1 * order;
            if (valA > valB) return 1 * order;
            return 0;
        });
        renderLeaderboard(listToSort, $id('globalLbBtn').classList.contains('active') ? 'global' : 'local');
    });
  }

  if (finalSubmit) {
    finalSubmit.addEventListener('click', (e) => {
      playSound('button');
      submitFinalWord();
    });
  }
  
  if (shuffleBtn) {
    shuffleBtn.addEventListener('click', () => {
      playSound('shuffle');
      if (manualFinalWord && $id('secretLettersText')) {
        if (finalWordDifficulty === 'hard') {
          scrambledFinalWord = scramble(manualFinalWord.replace(/ /g, '').toUpperCase());
          $id('secretLettersText').innerHTML = scrambledFinalWord.split('').join(' ');
        } else {
          scrambledFinalWord = manualFinalWord.toUpperCase().split(' ').map(scramble).join(' ');
          $id('secretLettersText').innerHTML = scrambledFinalWord.split(' ').map(w => w.split('').join(' ')).join('&nbsp;&nbsp;&nbsp;');
        }
        const firstBubble = finalWordInputContainer.querySelector('.final-bubble');
        if (firstBubble) {
            firstBubble.dispatchEvent(new Event('input', { bubbles: true }));
        }
      }
    });
  }

  // Settings Modal Logic
  if (settingsButton) {
    settingsButton.addEventListener('click', () => {
      playSound('modal');
      settingsModal.style.display = 'flex';
      settingsModal.setAttribute('aria-hidden', 'false');
      if (untrapModal) untrapModal();
      untrapModal = trapFocus(settingsModal);
    });
  }

  // NEW: Add click listener for theme toggle inside settings
  if (themeToggleSwitch) {
    themeToggleSwitch.addEventListener('click', toggleTheme);
  }

  function closeSettingsModal() {
    if (!settingsModal) return;
    settingsModal.style.display = 'none';
    settingsModal.setAttribute('aria-hidden', 'true');
    if (untrapModal) { untrapModal(); untrapModal = null; }
    if (settingsButton) settingsButton.focus();
  }

  if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', () => { playSound('button'); closeSettingsModal(); });
  
  // Difficulty Toggle
  function updateDifficultyButtons() {
    if (difficultyEasy) difficultyEasy.classList.toggle('active', finalWordDifficulty === 'easy');
    if (difficultyHard) difficultyHard.classList.toggle('active', finalWordDifficulty === 'hard');
  }

  if (difficultyEasy) {
    difficultyEasy.addEventListener('click', () => {
      playSound('button');
      finalWordDifficulty = 'easy';
      localStorage.setItem('wordLadderDifficulty', 'easy');
      updateDifficultyButtons();
    });
  }
  if (difficultyHard) {
    difficultyHard.addEventListener('click', () => {
      playSound('button');
      finalWordDifficulty = 'hard';
      localStorage.setItem('wordLadderDifficulty', 'hard');
      updateDifficultyButtons();
    });
  }

  // Calendar state
  let currentCalendarDate = new Date();
  let availableGameDates = new Set();
  
  // JSONP callback for calendar data
  window.handleCalendarData = function(data) {
    try {
      if (data && data.error) {
        throw new Error(`Error from Google Sheets: ${data.error}`);
      }
      const dates = new Set();
      
      if (data && data.availableDates) {
        data.availableDates.forEach(dateStr => {
          if (dateStr && /^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
            dates.add(dateStr);
          }
        });
      } else if (data && data.values) {
        data.values.slice(1).forEach(row => {
          if (row[0] && row[0] !== 'Date' && row[0] !== 'A (Date)') {
            const dateStr = String(row[0]).trim();
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
              const testDate = new Date(dateStr + 'T00:00:00');
              if (!isNaN(testDate.getTime()) && testDate.toISOString().startsWith(dateStr)) {
                dates.add(dateStr);
              }
            }
          }
        });
      }
      
      availableGameDates.clear();
      availableGameDates = dates;
      renderCalendar();
    } catch (error) {
      availableGameDates = new Set();
      renderCalendar();
    }
  };
  
  function loadPreviousGames() {
  // Use cached data if available
  if (puzzleCache.size > 0) {
    availableGameDates = new Set(puzzleCache.keys());
    renderCalendar();
    return;
  }
  // Fallback to network request
  const script = document.createElement('script');
  // *** The Fix: Add a timestamp as a query parameter. ***
  script.src = `${_0x3c4d}?tab=calendar&callback=handleCalendarData&v=${cacheBuster}`;
  const cleanup = () => {
    if (script.parentNode) {
      document.head.removeChild(script);
    }
  };
  script.onerror = () => {
    cleanup();
    availableGameDates = new Set();
    renderCalendar();
  };
  script.onload = () => {
    cleanup();
  };
  document.head.appendChild(script);
}
  
  function renderCalendar() {
    const monthYear = $id('calendar-month-year');
    const grid = $id('calendar-grid');
    if (!monthYear || !grid) return;
    
    grid.innerHTML = `
      <div class="calendar-day-header">S</div><div class="calendar-day-header">M</div><div class="calendar-day-header">T</div><div class="calendar-day-header">W</div><div class="calendar-day-header">T</div><div class="calendar-day-header">F</div><div class="calendar-day-header">S</div>
    `;

    const year = currentCalendarDate.getFullYear();
    const month = currentCalendarDate.getMonth();
    const today = new Date();
    
    monthYear.textContent = new Intl.DateTimeFormat('en-US', { 
      month: 'long', 
      year: 'numeric' 
    }).format(currentCalendarDate);
    
    const firstDay = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const daysInPrevMonth = new Date(year, month, 0).getDate();
    
    for (let i = firstDay - 1; i >= 0; i--) {
      const day = document.createElement('div');
      day.className = 'calendar-day other-month';
      day.textContent = daysInPrevMonth - i;
      grid.appendChild(day);
    }
    
    for (let day = 1; day <= daysInMonth; day++) {
      const dayEl = document.createElement('div');
      dayEl.className = 'calendar-day';
      dayEl.textContent = day;
      
      const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
      const isToday = year === today.getFullYear() && month === today.getMonth() && day === today.getDate();
      
      if (isToday) {
        dayEl.classList.add('today');
        dayEl.classList.add('has-game');
        dayEl.dataset.dateStr = dateStr;
        if (!selectedGameDate) {
          dayEl.classList.add('selected');
        }
      } else if (availableGameDates.has(dateStr)) {
        dayEl.classList.add('has-game');
        dayEl.dataset.dateStr = dateStr;
        if (isDateCompleted(dateStr)) {
          dayEl.classList.add('completed');
        }
      }
      
      if (selectedGameDate === dateStr) {
        dayEl.classList.add('selected');
      }
      
      grid.appendChild(dayEl);
    }
    
    const totalCells = grid.children.length - 7;
    const remainingCells = 42 - totalCells;
    for (let day = 1; day <= remainingCells; day++) {
      const dayEl = document.createElement('div');
      dayEl.className = 'calendar-day other-month';
      dayEl.textContent = day;
      grid.appendChild(dayEl);
    }
  }
  
  function selectGameDate(dateStr, isUiUpdateOnly = false) {
    console.log(`📅 Selecting game date: ${dateStr}`);
    const startTime = performance.now();
    
    selectedGameDate = dateStr;
    renderCalendar();

    const subtitle = $id('hero').querySelector('.subtitle');
    if (subtitle) {
        const date = new Date(dateStr + 'T00:00:00');
        const dateString = date.toLocaleDateString('en-US', { month: 'long', day: 'numeric' });
        subtitle.innerHTML = `💎 Playing game from ${dateString} 💎 <br> <button id="playTodaysGameBtn" class="link-btn" style="font-size: 0.9rem; padding: 0.2rem 0.5rem; margin-top: 0.5rem;">Play Today's Game</button>`;
        
        const playTodaysGameBtn = $id('playTodaysGameBtn');
        if (playTodaysGameBtn) {
            playTodaysGameBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                clearSelectedGame();
            });
        }
    }
    if (isUiUpdateOnly) return;
    
    console.log(`🔍 Cache has ${puzzleCache.size} puzzles`);
    
    // Try instant cache load first
    if (loadPuzzleFromCache(dateStr)) {
      // --- FIX: Manually update game state from cached config ---
      ladderData = gameConfig.ladderData;
      manualFinalWord = gameConfig.finalWord;
      manualFinalHint = gameConfig.finalHint;
      // --- END FIX ---

      const loadTime = performance.now() - startTime;
      console.log(`⚡ Date selection completed in ${loadTime.toFixed(2)}ms (from cache)`);
      
      const wordsCountEl = $id('wordsToClimbCount');
      if (wordsCountEl) wordsCountEl.textContent = ladderData.length;
      
      hideButtonLoading(timerModeBtn);
      hideButtonLoading(normalModeBtn);
      hideButtonLoading(unlimitedModeBtn);
      
      if (calendarDropdown) calendarDropdown.classList.remove('show');
      return;
    }
    
    // Fallback to network load
    console.log('🌐 Cache miss, loading from network...');
    showButtonLoading(timerModeBtn);
    showButtonLoading(normalModeBtn);
    showButtonLoading(unlimitedModeBtn);
    
    const wordsCountEl = $id('wordsToClimbCount');
    if (wordsCountEl) {
      wordsCountEl.innerHTML = '<div class="loading"></div>';
    }
    
    window.handleDateGameData = function(data) {
      const scripts = document.querySelectorAll('script[src*="date="]');
      scripts.forEach(s => {
        if (s.timeoutId) clearTimeout(s.timeoutId);
      });
      try {
        if (data.values && data.values.length > 1) {
          const rows = data.values.slice(1);
          const newLadderData = [];
          let newFinalWord = '';
          let newFinalHint = '';
          
          rows.forEach(row => {
            if (row[0] === 'FINAL') {
              newFinalWord = row[1] || '';
              newFinalHint = row[2] || 'Hint: A secret word awaits…';
            } else if (row[0] && row[0] !== 'FINAL' && row[0] !== 'Word' && row[0] !== 'A (Word)') {
              const wordData = { word: row[0].toUpperCase() };
              if (row[1]) wordData.hint = row[1];
              if (row[2] !== '' && row[2] !== null && row[2] !== undefined) {
                if (typeof row[2] === 'number') {
                  wordData.diamondIndex = [row[2]];
                } else {
                  const cellValue = String(row[2]).trim();
                  if (cellValue && cellValue !== '') {
                    if (cellValue.includes(',')) {
                      const indices = cellValue.split(',').map(i => parseInt(i.trim())).filter(i => !isNaN(i));
                      if (indices.length > 0) wordData.diamondIndex = indices;
                    } else {
                      const index = parseInt(cellValue);
                      if (!isNaN(index)) wordData.diamondIndex = [index];
                    }
                  }
                }
              }
              newLadderData.push(wordData);
            }
          });
          
          if (newLadderData.length > 0) {
            gameConfig.ladderData = newLadderData;
            gameConfig.finalWord = newFinalWord;
            gameConfig.finalHint = newFinalHint;
            
            ladderData = newLadderData;
            manualFinalWord = newFinalWord;
            manualFinalHint = newFinalHint;
            
            sessionStorage.setItem('cachedGameConfig', JSON.stringify(gameConfig));
            sessionStorage.setItem('selectedGameDate', selectedGameDate);
            
            const wordsCount = $id('wordsToClimbCount');
            if (wordsCount) {
              wordsCount.textContent = newLadderData.length;
            }
            
            if (calendarDropdown) calendarDropdown.classList.remove('show');
            
            const timerBtn = $id('timerModeBtn');
            const normalBtn = $id('normalModeBtn');
            const unlimitedBtn = $id('unlimitedModeBtn');
            if (timerBtn) hideButtonLoading(timerBtn);
            if (normalBtn) hideButtonLoading(normalBtn);
            if (unlimitedBtn) hideButtonLoading(unlimitedBtn);
          }
        } 
      } catch (error) {
      } finally {
        hideButtonLoading(timerModeBtn);
        hideButtonLoading(normalModeBtn);
        hideButtonLoading(unlimitedModeBtn);
      }
      
      const timerBtn = $id('timerModeBtn');
      const normalBtn = $id('normalModeBtn');
      const unlimitedBtn = $id('unlimitedModeBtn');
      if (timerBtn) hideButtonLoading(timerBtn);
      if (normalBtn) hideButtonLoading(normalBtn);
      if (unlimitedBtn) hideButtonLoading(unlimitedBtn);
      
      setTimeout(() => {
        renderCalendar();
      }, 100);
    };
    
    const script = document.createElement('script');
    script.src = _0x3c4d + '?date=' + encodeURIComponent(dateStr) + '&callback=handleDateGameData';
    
    const cleanup = () => {
      if (script.parentNode) script.parentNode.removeChild(script);
    };
    
    script.onerror = () => {
      cleanup();
    };
    
    document.head.appendChild(script);
    
    const timeoutId = setTimeout(() => {
      cleanup();
      const timerBtn = $id('timerModeBtn');
      const normalBtn = $id('normalModeBtn');
      if (timerBtn) hideButtonLoading(timerBtn);
      if (normalBtn) hideButtonLoading(normalBtn);
    }, 8000);
    
    script.timeoutId = timeoutId;
  }
  
  function clearSelectedGame() {
    sessionStorage.removeItem('selectedGameDate');
    sessionStorage.removeItem('cachedGameConfig');
    selectedGameDate = null;
    const subtitle = $id('hero').querySelector('.subtitle');
    if (subtitle) subtitle.innerHTML = `💎 Climb • Collect • Conquer 💎`;
    renderCalendar();
    loadTodaysGame();
  }
  
  window.changeMonth = function(direction) {
    currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
    renderCalendar();
  };
  
  const calendarIcon = $id('calendar-icon');
  const calendarDropdown = $id('calendar-dropdown');
  
  if (calendarIcon && calendarDropdown) {
    calendarIcon.addEventListener('click', (e) => {
      e.stopPropagation();
      calendarDropdown.classList.toggle('show');
    });
    
    document.addEventListener('click', (e) => {
      if (!calendarDropdown.contains(e.target) && !calendarIcon.contains(e.target)) {
        calendarDropdown.classList.remove('show');
      }
    });
  }
  
  const calendarGrid = $id('calendar-grid');
  if (calendarGrid) {
    calendarGrid.addEventListener('click', (e) => {
      const dayEl = e.target.closest('.calendar-day');
      if (dayEl && dayEl.classList.contains('has-game') && dayEl.dataset.dateStr && !dayEl.classList.contains('selected')) {
        if (calendarDropdown) calendarDropdown.classList.remove('show');
        
        const today = new Date();
        const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

        if (dayEl.dataset.dateStr === todayStr) {
            clearSelectedGame();
        } else {
            selectGameDate(dayEl.dataset.dateStr, false);
        }
      }
    });
  }
  
  // Dark Mode Functions
  function initTheme() {
    const savedTheme = localStorage.getItem('wordLadderTheme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    updateThemeIcon(savedTheme);
  }
  
  function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', newTheme);
    localStorage.setItem('wordLadderTheme', newTheme);
    updateThemeIcon(newTheme);
  }
  
  function updateThemeIcon(theme) {
    if (themeToggle) {
      themeToggle.textContent = theme === 'light' ? '🌙' : '☀️';
    }
  }
  
  function openShortcutsModal() {
    if (!shortcutsModal) return;
    playSound('modal');
    shortcutsModal.style.display = 'flex';
    shortcutsModal.setAttribute('aria-hidden', 'false');
    if (untrapModal) untrapModal();
    untrapModal = trapFocus(shortcutsModal);
  }
  
  function closeShortcutsModal() {
    if (!shortcutsModal) return;
    shortcutsModal.style.display = 'none';
    shortcutsModal.setAttribute('aria-hidden', 'true');
    if (untrapModal) { untrapModal(); untrapModal = null; }
  }
  
  // NEW: Add ESC key listener for settings modal
  if (settingsModal) {
    settingsModal.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeSettingsModal();
    });
  }

  initTheme();
  updateAllSoundUI();
  updateDifficultyButtons();
  createFloatingParticles();
  renderCalendar();
  loadPreviousGames();

  function initializeApp() {
    startNextGameCountdown(); // Start the countdown on app load
    createFloatingParticles();
    updateStreakAndStats();
    
    // Always start with loading state
    showButtonLoading(timerModeBtn);
    showButtonLoading(normalModeBtn);
    showButtonLoading(unlimitedModeBtn);
    
    const cachedDate = sessionStorage.getItem('selectedGameDate');
    const cachedConfig = sessionStorage.getItem('cachedGameConfig');
    
    if (cachedDate && cachedConfig) {
      try {
        selectedGameDate = cachedDate;
        const parsedConfig = JSON.parse(cachedConfig);
        
        // Validate cached data before using it
        if (parsedConfig.ladderData && parsedConfig.ladderData.length > 0) {
          gameConfig = parsedConfig;
          ladderData = gameConfig.ladderData;
          manualFinalWord = gameConfig.finalWord;
          manualFinalHint = gameConfig.finalHint;
          
          resetToStartScreen();
          
          // Only enable buttons if we have valid cached data
          hideButtonLoading(timerModeBtn);
          hideButtonLoading(normalModeBtn);
          hideButtonLoading(unlimitedModeBtn);
          if (leaderboardBtn) leaderboardBtn.disabled = false;
          
          return;
        } else {
          // Cached data is invalid, clear it
          clearSelectedGame();
        }
      } catch (e) {
        clearSelectedGame();
      }
    }
    
    // No valid cached data, start fresh
    resetToStartScreen();
    // loadTodaysGame() is called from resetToStartScreen()
  }

   // In your WordPlay vX.XX.html <script> tag

async function loadTodaysGame() {
    showButtonLoading(timerModeBtn);
    showButtonLoading(normalModeBtn);
    showButtonLoading(unlimitedModeBtn);
    if (leaderboardBtn) leaderboardBtn.disabled = true;
    $id('wordsToClimbCount').innerHTML = '<div class="loading"></div>';

    try {
        // 1. Fetch the latest timestamp from the Google Sheet
        const response = await fetch(`${_0x3c4d}?action=getTimestamp&_=${Date.now()}`);
        const serverData = await response.json();
        const serverTimestamp = serverData.lastUpdated;

        // 2. Get local cache
        const localCache = JSON.parse(localStorage.getItem(DATA_CACHE_KEY)) || {};

        // 3. Compare timestamps
        if (localCache.timestamp === serverTimestamp && localCache.puzzles) {
            console.log('✅ Data cache is up-to-date. Loading from localStorage.');
            puzzleCache = new Map(localCache.puzzles);
        } else {
            console.log('🔄 Data is stale or missing. Fetching new data from Google Sheet.');
            // 4. Fetch all puzzle data
            const puzzlesResponse = await fetch(`${_0x3c4d}?action=getAllPuzzles&_=${Date.now()}`);
            const batchData = await puzzlesResponse.json();

            if (batchData && batchData.puzzles) {
                puzzleCache.clear();
                Object.entries(batchData.puzzles).forEach(([date, puzzleData]) => {
                    puzzleCache.set(date, puzzleData);
                });

                // 5. Save new data and timestamp to localStorage
                localStorage.setItem(DATA_CACHE_KEY, JSON.stringify({
                    timestamp: serverTimestamp,
                    puzzles: Array.from(puzzleCache.entries())
                }));
                console.log('💾 New data saved to cache.');
            }
        }

        // Finally, load today's game from the now-updated puzzleCache
        const today = getEstDateString();
        if (loadPuzzleFromCache(today)) {
            ladderData = gameConfig.ladderData;
            manualFinalWord = gameConfig.finalWord;
            manualFinalHint = gameConfig.finalHint;
        }

    } catch (error) {
        console.error("💥 Failed to load game data:", error);
        // Attempt to load from old cache as a fallback
        const oldCache = JSON.parse(localStorage.getItem(DATA_CACHE_KEY));
        if (oldCache && oldCache.puzzles) {
            console.warn("Retrying with stale cache due to error.");
            puzzleCache = new Map(oldCache.puzzles);
            loadPuzzleFromCache(getEstDateString());
        } else {
             $id('wordsToClimbCount').textContent = 'Error';
        }
    } finally {
        // Update UI regardless of success or failure
        $id('wordsToClimbCount').textContent = ladderData.length || 'N/A';
        hideButtonLoading(timerModeBtn);
        hideButtonLoading(normalModeBtn);
        hideButtonLoading(unlimitedModeBtn);
        if (leaderboardBtn) leaderboardBtn.disabled = false;
    }
}

  initializeApp();
  
  // Custom Game Event Listeners
  if (createGameBtn) createGameBtn.addEventListener('click', () => { playSound('modal'); openBuilderModal(); });
  if (soundToggle) soundToggle.addEventListener('click', toggleSound);
  if (themeToggle) themeToggle.addEventListener('click', toggleTheme);
  if (closeShortcutsBtn) closeShortcutsBtn.addEventListener('click', () => { playSound('button'); closeShortcutsModal(); });
  if (closeBuilderBtn) closeBuilderBtn.addEventListener('click', () => { playSound('button'); closeBuilderModal(); });
  if (addWordBtn) addWordBtn.addEventListener('click', () => { playSound('button'); createWordBuilderRow(); });
  if (saveGameBtn) saveGameBtn.addEventListener('click', () => { playSound('button'); saveCustomGame(); });
  if (myGamesBtn) myGamesBtn.addEventListener('click', () => { playSound('modal'); openMyGamesModal(); });
  if (closeMyGamesBtn) closeMyGamesBtn.addEventListener('click', () => { playSound('button'); closeMyGamesModal(); });
  if (myGamesBody) {
    myGamesBody.addEventListener('click', e => {
      const loadBtn = e.target.closest('.load-custom-btn');
      const publishBtn = e.target.closest('.publish-custom-btn');
      const editBtn = e.target.closest('.edit-custom-btn');
      const deleteBtn = e.target.closest('.delete-custom-btn');
      if (loadBtn) loadCustomGame(loadBtn.dataset.gameId);
      if (publishBtn) publishCustomGame(publishBtn.dataset.gameId);
      if (editBtn) editCustomGame(editBtn.dataset.gameId);
      if (deleteBtn) deleteCustomGame(deleteBtn.dataset.gameId);
    });
  }
  if (communityGamesBtn) communityGamesBtn.addEventListener('click', () => { playSound('modal'); openCommunityModal(); });
  if (closeCommunityGamesBtn) closeCommunityGamesBtn.addEventListener('click', () => { playSound('button'); closeCommunityModal(); });
  $id('communityGamesBody')?.addEventListener('click', e => {
    const loadBtn = e.target.closest('.load-public-btn');
    if (loadBtn) playPublicGame(loadBtn.dataset.gameId);
  });
  
  function showButtonLoading(btn) {
    if (!btn) return;
    const content = btn.querySelector('.btn-content');
    const loading = btn.querySelector('.btn-loading');
    if (content) content.style.display = 'none';
    if (loading) loading.style.display = 'block';
    btn.disabled = true;
  }
  
  function hideButtonLoading(btn) {
    if (!btn) return;
    const content = btn.querySelector('.btn-content');
    const loading = btn.querySelector('.btn-loading');
    if (content) content.style.display = 'block';
    if (loading) loading.style.display = 'none';
    btn.disabled = false;
    
    // Play sound when game becomes available
    if (btn === timerModeBtn || btn === normalModeBtn || btn === unlimitedModeBtn) {
      playSound('button');
    }
  }
  
  if (ladder) {
    ladder.addEventListener('input', (e) => {
        const input = e.target;
        if (!input.classList.contains('bubble')) return;
        
        // Save undo state before changing
        const oldValue = input.value;
        const newValue = input.value.toUpperCase().replace(/[^A-Z]/g, '');
        
        if (oldValue !== newValue && newValue && newValue.length === 1) {
          saveUndoState('letter', {
            stepIndex: parseInt(input.dataset.index),
            letterIndex: parseInt(input.dataset.letter),
            oldValue: oldValue
          });
          playSound('type');
        }
        
        input.value = input.value.toUpperCase().replace(/[^A-Z]/g, '');
        const index = parseInt(input.dataset.index);
        const letterPos = parseInt(input.dataset.letter);
        const stepDiv = ladder.children[index];
        if (!stepDiv) return;
        const inputs = stepDiv.inputs || [];
        
        inputs.forEach(inp => inp.classList.remove('incorrect'));
        
        if (input.value && letterPos < inputs.length - 1) {
            const nextInput = inputs[letterPos + 1];
            if (isMobile) {
                setTimeout(() => nextInput.focus(), 50);
            } else {
                nextInput.focus();
            }
        }   // Auto-submit logic for timer and unlimited modes
        if (currentMode === 'timer' || currentMode === 'unlimited') {
          const isComplete = inputs.every(inp => inp.disabled || inp.value);
          if (isComplete) {
            setTimeout(() => submitWordGuess(index), 50);
          }
        }
        saveGameState();
    });

    ladder.addEventListener('keyup', (e) => {
        const input = e.target;
        if (!input.classList.contains('bubble') || !input.value) return;

        const letterPos = parseInt(input.dataset.letter);
        const index = parseInt(input.dataset.index);
        const stepDiv = ladder.children[index];
        if (!stepDiv) return;
        const inputs = stepDiv.inputs || [];

        if (letterPos < inputs.length - 1) {
            const nextInput = inputs[letterPos + 1];
            if (nextInput && !nextInput.disabled) {
                nextInput.focus();
            }
        }
    });

    ladder.addEventListener('keydown', (e) => {
        const input = e.target;
        if (!input.classList.contains('bubble')) return;

        const index = parseInt(input.dataset.index);
        const letterPos = parseInt(input.dataset.letter);
        const stepDiv = ladder.children[index];
        if (!stepDiv) return;
        const inputs = stepDiv.inputs || [];
        
        if (e.key === 'Enter' && (currentMode === 'normal' || currentMode === 'unlimited')) {
            e.preventDefault();
            submitWordGuess(index);
        }

        if (e.key === 'Backspace' && !input.value && letterPos > 1) {
            e.preventDefault();
            const prev = inputs[letterPos - 1];
            if (prev && !prev.disabled) {
                prev.value = '';
                prev.focus();
            }
        }
    });
  }

  if (finalWordInputContainer) {
    finalWordInputContainer.addEventListener('input', (e) => {
        const currentInput = e.target;
        if (!currentInput.classList.contains('final-bubble')) return;

        currentInput.value = currentInput.value.toUpperCase().replace(/[^A-Z]/g, '');
        updateFinalWordScrambleDisplay();
    });

    finalWordInputContainer.addEventListener('keyup', (e) => {
        const currentInput = e.target;
        if (!currentInput.classList.contains('final-bubble') || !currentInput.value) return;

        const allInputs = Array.from(finalWordInputContainer.querySelectorAll('.final-bubble'));
        const currentIndex = allInputs.indexOf(currentInput);

        if (currentIndex < allInputs.length - 1) {
            const nextInput = allInputs[currentIndex + 1];
            if (nextInput) {
                nextInput.focus();
            }
        }
    });

    finalWordInputContainer.addEventListener('keydown', (e) => {
        const currentInput = e.target;
        if (!currentInput.classList.contains('final-bubble')) return;

        const allInputs = Array.from(finalWordInputContainer.querySelectorAll('.final-bubble'));
        const currentIndex = allInputs.indexOf(currentInput);

        if (e.key === 'Enter') {
            e.preventDefault();
            submitFinalWord();
        }
         if (e.key === 'Backspace') {
            if (!currentInput.value && currentIndex > 0) {
                e.preventDefault();
                const prevInput = allInputs[currentIndex - 1];
                if (prevInput) {
                    prevInput.value = '';
                    prevInput.focus();
                    updateFinalWordScrambleDisplay();
                }
            } else {
                setTimeout(updateFinalWordScrambleDisplay, 0);
            }
        }
    });
  }
  
  // Custom Game Functions
  function openCommunityModal() {
    if (!communityGamesModal) return;
    const body = $id('communityGamesBody');
    body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--muted)"><div class="loading"></div><div style="margin-top:1rem">Fetching community puzzles...</div></div>`;

    communityGamesModal.style.display = 'flex';
    communityGamesModal.setAttribute('aria-hidden', 'false');
    if (untrapModal) untrapModal();
    untrapModal = trapFocus(communityGamesModal);
    
    body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--muted)"><div class="loading"></div><div style="margin-top:1rem">Fetching community puzzles...</div></div>`;

    communityGamesModal.style.display = 'flex';
    communityGamesModal.setAttribute('aria-hidden', 'false');
    if (untrapModal) untrapModal();
    untrapModal = trapFocus(communityGamesModal);

    window.handleCommunityGamesData = function(data) {
      try {
        if (data && data.error) {
          console.error('Community games error:', data.error);
          throw new Error(data.error);
        }
        const games = [];
        if (data && data.values && data.values.length > 1) {
          data.values.slice(1).forEach(row => {
            if (row[0] && row[1] && row[2]) {
              games.push({
                id: row[0],
                name: row[1], 
                creator: row[2]
              });
            }
          });
        }
        if (games.length === 0) {
          body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--muted)">No community games published yet.</div>`;
          return;
        }
        body.innerHTML = `<ul class="community-games-list">${games.map(game => `<li class="community-games-item"><div><span style="font-weight:600">${String(game.name || '').replace(/</g, "&lt;")}</span><div class="community-games-item-details">by ${String(game.creator || 'Anonymous').replace(/</g, "&lt;")}</div></div><button class="btn primary load-public-btn" data-game-id="${game.id}" style="padding:0.5rem 1rem;">Load Game</button></li>`).join('')}</ul>`;
      } catch (error) {
        body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">Could not load community games.</div>`;
      }
    };
    
    try {
      const script = document.createElement('script');
      // Use fetch instead of JSONP since backend returns JSON
      fetch(`${_0x3c4d}?action=getPublicGamesList`)
        .then(response => response.json())
        .then(data => {
          const games = data && data.games ? data.games : [];
          if (games.length === 0) {
            body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--muted)">No community games published yet.</div>`;
            return;
          }
          body.innerHTML = `<ul class="community-games-list">${games.map(game => `<li class="community-games-item"><div><span style="font-weight:600">${String(game.name || '').replace(/</g, "&lt;")}</span><div class="community-games-item-details">by ${String(game.creator || 'Anonymous').replace(/</g, "&lt;")}</div></div><button class="btn primary load-public-btn" data-game-id="${game.id}" style="padding:0.5rem 1rem;">Load Game</button></li>`).join('')}</ul>`;
        })
        .catch(() => {
          body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">🌐 Community games are currently unavailable.<br><small style="margin-top:0.5rem;display:block;color:var(--muted)">Server connection failed. Please try again later.</small></div>`;
        });
      return;
      script.src = `unused`;
      
      const cleanup = () => {
        try {
          if (script.parentNode) document.head.removeChild(script);
        } catch (e) {
          console.warn('Script cleanup failed:', e);
        }
      };
      
      script.onerror = (e) => {
        cleanup();
        body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">🌐 Community games are currently unavailable.<br><small style="margin-top:0.5rem;display:block;color:var(--muted)">Server connection failed. Please try again later.</small></div>`;
      };
      
      script.onload = () => {
        setTimeout(() => {
          if (body.innerHTML.includes('Fetching community puzzles')) {
            body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">Server response timeout. Please try again.</div>`;
          }
        }, 5000);
        cleanup();
      };
      
      setTimeout(() => {
        if (script.parentNode) {
          cleanup();
          body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">Request timed out. Please try again.</div>`;
        }
      }, 10000);
      
      document.head.appendChild(script);
    } catch (error) {
      body.innerHTML = `<div style="text-align:center;padding:2rem;color:var(--bad)">🌐 Community games are currently unavailable.<br><small style="margin-top:0.5rem;display:block;color:var(--muted)">Unable to connect to server.</small></div>`;
    }
  }

  function closeCommunityModal() {
    if (!communityGamesModal) return;
    communityGamesModal.style.display = 'none';
    communityGamesModal.setAttribute('aria-hidden', 'true');
    if (untrapModal) { untrapModal(); untrapModal = null; }
  }

  function playPublicGame(gameId) {
    closeCommunityModal();
    
    // Show loading indicators
    showButtonLoading(timerModeBtn);
    showButtonLoading(normalModeBtn);
    showButtonLoading(unlimitedModeBtn);
    const wordsCount = $id('wordsToClimbCount');
    if (wordsCount) wordsCount.innerHTML = '<div class="loading"></div>';
    
    window.handlePublicGameData = function(data) {
      try {
        if (data && data.error) {
          throw new Error(data.error);
        }
        
        // Check if the data structure is valid
        if (!data || !data.values || !Array.isArray(data.values) || data.values.length < 2) {
          throw new Error('This community game has invalid data structure.');
        }
        
        // Check if GameDataJSON contains actual game data vs just creator name
        const firstDataRow = data.values[1]; // Skip header row
        if (!firstDataRow || !firstDataRow[0] || typeof firstDataRow[0] !== 'string') {
          throw new Error('This community game has corrupted GameDataJSON - contains invalid word data.');
        }
        
        // Check if it looks like just a name instead of game data
        if (firstDataRow[0].length < 3 || !/^[A-Z]+$/i.test(firstDataRow[0].replace(/\s/g, ''))) {
          throw new Error(`This community game has corrupted data. The GameDataJSON field contains "${firstDataRow[0]}" instead of actual game data. Please contact the creator to fix it.`);
        }
        
        const parsedData = parseGameDataFromValues(data);
        if (parsedData) {
          // Update both local variables and gameConfig
          ladderData = parsedData.words;
          manualFinalWord = parsedData.finalWord;
          manualFinalHint = parsedData.finalHint;
          
          // Update gameConfig to match
          gameConfig.ladderData = parsedData.words;
          gameConfig.finalWord = parsedData.finalWord;
          gameConfig.finalHint = parsedData.finalHint;
          
          // Update subtitle to show game info
          const subtitle = document.querySelector('.subtitle');
          if (subtitle) {
            subtitle.innerHTML = `🎮 ${data.name || 'Community Game'} <br><small style="opacity:0.7">by ${data.creator || 'Anonymous'}</small><br><button id="playTodaysGameBtn" class="link-btn" style="font-size: 0.9rem; padding: 0.2rem 0.5rem; margin-top: 0.5rem;">Play Today's Game</button>`;
            
            const playTodaysGameBtn = $id('playTodaysGameBtn');
            if (playTodaysGameBtn) {
              playTodaysGameBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                clearSelectedGame();
              });
            }
          }
          
          // Update word count and hide loading
          const wordsCount = $id('wordsToClimbCount');
          if (wordsCount) wordsCount.textContent = parsedData.words.length;
          hideButtonLoading(timerModeBtn);
          hideButtonLoading(normalModeBtn);
          hideButtonLoading(unlimitedModeBtn);
        } else {
          hideButtonLoading(timerModeBtn);
          hideButtonLoading(normalModeBtn);
          hideButtonLoading(unlimitedModeBtn);
          alert('Failed to load game data.');
          resetToStartScreen();
        }
      } catch (error) {
        hideButtonLoading(timerModeBtn);
        hideButtonLoading(normalModeBtn);
        hideButtonLoading(unlimitedModeBtn);
        alert('Failed to load game.');
        resetToStartScreen();
      }
    };
    
    const script = document.createElement('script');
    script.src = `${_0x3c4d}?tab=publicGame&gameId=${gameId}&callback=handlePublicGameData&_=${Date.now()}`;
    
    const cleanup = () => {
      if (script.parentNode) document.head.removeChild(script);
    };
    
    script.onerror = (e) => {
      cleanup();
      hideButtonLoading(timerModeBtn);
      hideButtonLoading(normalModeBtn);
      hideButtonLoading(unlimitedModeBtn);
      alert('Failed to load game.');
      resetToStartScreen();
    };
    
    script.onload = () => {
      setTimeout(() => {
        cleanup();
      }, 100);
    };
    
    // Add timeout for the entire request
    setTimeout(() => {
      if (script.parentNode) {
        cleanup();
        hideButtonLoading(timerModeBtn);
        hideButtonLoading(normalModeBtn);
        hideButtonLoading(unlimitedModeBtn);
        alert('Request timed out. Please try again.');
        resetToStartScreen();
      }
    }, 10000);
    
    document.head.appendChild(script);
  }
  
  // Custom Game Builder Functions
  function openBuilderModal() {
    if (!gameBuilderModal) return;
    gameBuilderModal.style.display = 'flex';
    gameBuilderModal.setAttribute('aria-hidden', 'false');
    if (untrapModal) untrapModal();
    untrapModal = trapFocus(gameBuilderModal);
    
    if (gameNameInput) gameNameInput.value = '';
    if (finalWordInput) finalWordInput.value = '';
    if (finalHintInput) finalHintInput.value = '';
    if (wordBuilderContainer) wordBuilderContainer.innerHTML = '';
    
    createWordBuilderRow();  // First word
    createWordBuilderRow();  // Middle word
    createWordBuilderRow();  // Last word
  }
  
  function closeBuilderModal() {
    if (!gameBuilderModal) return;
    gameBuilderModal.style.display = 'none';
    gameBuilderModal.setAttribute('aria-hidden', 'true');
    if (untrapModal) { untrapModal(); untrapModal = null; }
  }
  
  function createWordBuilderRow(word = '', hint = '', diamonds = '', isLocked = false) {
    if (!wordBuilderContainer) return;
    
    const row = document.createElement('div');
    row.style.cssText = 'display:flex;gap:0.5rem;align-items:center;padding:0.5rem;background:rgba(0,0,0,0.02);border-radius:8px';
    
    const isFirst = wordBuilderContainer.children.length === 0;
    
    const wordInput = document.createElement('input');
    wordInput.type = 'text';
    wordInput.placeholder = 'WORD';
    wordInput.value = word;
    wordInput.disabled = false;
    wordInput.style.cssText = 'width:160px;padding:0.5rem;border:1px solid #ccc;border-radius:4px;text-transform:uppercase';
    wordInput.maxLength = 15;
    
    const hintInput = document.createElement('input');
    hintInput.type = 'text';
    hintInput.placeholder = isFirst ? 'Hint not needed' : 'Hint (how it connects to above word)';
    hintInput.value = hint;
    hintInput.disabled = isFirst;
    hintInput.style.cssText = 'width:240px;padding:0.5rem;border:1px solid #ccc;border-radius:4px';
    hintInput.maxLength = 50;
    
    const diamondInput = document.createElement('input');
    diamondInput.type = 'text';
    diamondInput.placeholder = 'A,B,C';
    diamondInput.value = diamonds;
    diamondInput.disabled = false;
    diamondInput.style.cssText = 'width:120px;padding:0.5rem;border:1px solid #ccc;border-radius:4px';
    diamondInput.title = 'Secret letters (actual letters, comma-separated)';
    
    const validateSecretLetters = () => {
      const word = wordInput.value.trim().toUpperCase();
      const letters = diamondInput.value.trim();
      if (!word || !letters) {
        diamondInput.style.borderColor = '#ccc';
        return;
      }
      const secretLetters = letters.split(',').map(l => l.trim().toUpperCase()).filter(l => l.length === 1);
      const invalid = secretLetters.some(letter => !word.includes(letter));
      diamondInput.style.borderColor = invalid ? 'var(--bad)' : 'var(--ok)';
    };
    
    wordInput.addEventListener('input', validateSecretLetters);
    diamondInput.addEventListener('input', validateSecretLetters);
    
    row.appendChild(wordInput);
    row.appendChild(hintInput);
    row.appendChild(diamondInput);
    
    setTimeout(validateSecretLetters, 0);
    
    const removeBtn = document.createElement('button');
    removeBtn.textContent = '×';
    removeBtn.type = 'button';
    removeBtn.style.cssText = 'width:30px;height:30px;border:none;background:var(--bad);color:white;border-radius:4px;cursor:pointer';
    removeBtn.onclick = () => row.remove();
    row.appendChild(removeBtn);
    
    // Add drag handle (but not for first word)
    if (!isFirst) {
      const dragBtn = document.createElement('button');
      dragBtn.textContent = '⋮⋮';
      dragBtn.type = 'button';
      dragBtn.style.cssText = 'width:30px;height:30px;border:none;background:#ccc;color:#666;border-radius:4px;cursor:grab;font-weight:bold';
      dragBtn.onmousedown = () => {
        let draggedRow = row;
        let placeholder = document.createElement('div');
        placeholder.style.cssText = 'height:2px;background:var(--accent);margin:2px 0;border-radius:1px';
        
        const onMouseMove = (e) => {
          const afterElement = getDragAfterElement(wordBuilderContainer, e.clientY);
          if (afterElement == null) {
            if (wordBuilderContainer.children[0] !== placeholder) {
              wordBuilderContainer.appendChild(placeholder);
            }
          } else {
            if (afterElement !== wordBuilderContainer.children[0]) {
              wordBuilderContainer.insertBefore(placeholder, afterElement);
            }
          }
        };
        
        const onMouseUp = () => {
          if (placeholder.parentNode) {
            wordBuilderContainer.insertBefore(draggedRow, placeholder);
            placeholder.remove();
          }
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      };
      row.appendChild(dragBtn);
    } else {
      // Empty space for first word to maintain alignment
      const spacer = document.createElement('div');
      spacer.style.cssText = 'width:30px;height:30px';
      row.appendChild(spacer);
    }
    
    wordBuilderContainer.appendChild(row);
  }
  
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.children].slice(1); // Skip first element
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
  
  function saveCustomGame() {
    if (!gameNameInput || !finalWordInput || !wordBuilderContainer) return;
    
    const name = gameNameInput.value.trim();
    const finalWord = finalWordInput.value.trim().toUpperCase();
    const finalHint = finalHintInput.value.trim() || 'A secret word awaits...';
    
    if (!name || !finalWord) {
      alert('Please enter a game name and final word.');
      return;
    }
    
    const rows = Array.from(wordBuilderContainer.children);
    const words = [];
    
    for (const row of rows) {
      const wordInput = row.querySelector('input[type="text"]');
      const hintInput = row.querySelectorAll('input[type="text"]')[1];
      const diamondInput = row.querySelectorAll('input[type="text"]')[2];
      
      const word = wordInput.value.trim().toUpperCase();
      const hint = hintInput.value.trim();
      const diamonds = diamondInput.value.trim();
      
      if (word) {
        const wordData = { word, hint };
        if (diamonds) {
          const letters = diamonds.split(',').map(l => l.trim().toUpperCase()).filter(l => l.length === 1 && /[A-Z]/.test(l));
          if (letters.length > 0) wordData.secretLetters = letters;
        }
        words.push(wordData);
      }
    }
    
    if (words.length < 3) {
      alert('Please add at least 3 words to create a game.');
      return;
    }
    
    // Validate secret letters exist in their words
    for (let i = 0; i < words.length; i++) {
      const wordData = words[i];
      if (wordData.secretLetters) {
        for (const letter of wordData.secretLetters) {
          if (!wordData.word.includes(letter)) {
            alert(`Secret letter '${letter}' does not exist in word '${wordData.word}' (row ${i + 1}).`);
            return;
          }
        }
      }
    }
    
    // Validate hints exist (except for first word)
    const missingHints = [];
    for (let i = 1; i < words.length; i++) {
      if (!words[i].hint) {
        missingHints.push(i + 1);
      }
    }
    if (missingHints.length > 0) {
      alert(`Missing hints for word${missingHints.length > 1 ? 's' : ''} in row${missingHints.length > 1 ? 's' : ''}: ${missingHints.join(', ')}.`);
      return;
    }
    
    const diamondLetters = [];
    words.forEach(wordData => {
      if (wordData.secretLetters) {
        wordData.secretLetters.forEach(letter => {
          diamondLetters.push(letter.toUpperCase());
        });
      }
    });
    
    const secretLettersStr = diamondLetters.join('').replace(/\s/g, '').split('').sort().join('');
    const finalWordStr = finalWord.replace(/\s/g, '').split('').sort().join('');
    if (secretLettersStr !== finalWordStr) {
      alert(`Secret letters (${diamondLetters.join('')}) don't form an anagram of final word (${finalWord}). Please adjust secret letters.`);
      return;
    }
    
    // Convert secret letters to indices for storage
    words.forEach(wordData => {
      if (wordData.secretLetters) {
        const indices = [];
        wordData.secretLetters.forEach(letter => {
          const index = wordData.word.indexOf(letter.toUpperCase());
          if (index !== -1) indices.push(index);
        });
        wordData.diamondIndex = indices;
        delete wordData.secretLetters;
      }
    });
    
    const customGames = JSON.parse(localStorage.getItem(CUSTOM_GAMES_KEY) || '[]');
    
    if (window.editingGameId) {
      const gameIndex = customGames.findIndex(g => g.id === window.editingGameId);
      if (gameIndex !== -1) {
        const existing = customGames[gameIndex];
        customGames[gameIndex] = {
          ...existing,
          name, words, finalWord, finalHint,
          modified: new Date().toISOString(),
          needsRepublish: existing.published || false
        };
      }
      window.editingGameId = null;
      alert('Game updated successfully!');
    } else {
      const gameData = {
        id: Date.now().toString(),
        name, words, finalWord, finalHint,
        created: new Date().toISOString()
      };
      customGames.push(gameData);
      alert('Game saved successfully!');
    }
    
    localStorage.setItem(CUSTOM_GAMES_KEY, JSON.stringify(customGames));
    closeBuilderModal();
    
    const saveBtn = $id('saveGameBtn');
    if (saveBtn) saveBtn.textContent = 'Save Game';
  }
  
  function openMyGamesModal() {
    if (!myGamesModal) return;
    myGamesModal.style.display = 'flex';
    myGamesModal.setAttribute('aria-hidden', 'false');
    if (untrapModal) untrapModal();
    untrapModal = trapFocus(myGamesModal);
    renderMyGames();
  }
  
  function closeMyGamesModal() {
    if (!myGamesModal) return;
    myGamesModal.style.display = 'none';
    myGamesModal.setAttribute('aria-hidden', 'true');
    if (untrapModal) { untrapModal(); untrapModal = null; }
  }
  
  function renderMyGames() {
    if (!myGamesBody) return;
    
    const customGames = JSON.parse(localStorage.getItem(CUSTOM_GAMES_KEY) || '[]');
    
    if (customGames.length === 0) {
      myGamesBody.innerHTML = '<div style="text-align:center;padding:2rem;color:var(--muted)">No custom games created yet. <br><button class="btn minor" onclick="closeMyGamesModal(); openBuilderModal();">Create Your First Game</button></div>';
      return;
    }
    
    myGamesBody.innerHTML = customGames.map(game => `
      <div style="border:1px solid #e2e8f0;border-radius:8px;padding:1rem;margin-bottom:1rem">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem">
          <h4 style="margin:0;color:var(--accent)">${game.name}</h4>
          <div style="display:flex;gap:0.5rem;flex-wrap:wrap">
            <button class="btn minor load-custom-btn" data-game-id="${game.id}" style="padding:0.3rem 0.8rem;font-size:0.8rem">Load Game</button>
            <button class="btn minor publish-custom-btn" data-game-id="${game.id}" style="padding:0.3rem 0.8rem;font-size:0.8rem">${game.published && !game.needsRepublish ? '🔒 Published' : game.needsRepublish ? 'Republish' : 'Publish'}</button>
            <button class="btn minor edit-custom-btn" data-game-id="${game.id}" style="padding:0.3rem 0.8rem;font-size:0.8rem">Edit</button>
            <button class="btn minor delete-custom-btn" data-game-id="${game.id}" style="padding:0.3rem 0.8rem;font-size:0.8rem;background:var(--bad);color:white">Delete</button>
          </div>
        </div>
        <div style="font-size:0.9rem;color:var(--muted)">
          ${game.words.length} words • Final: ${game.finalWord} • Created: ${new Date(game.created).toLocaleDateString()}
        </div>
      </div>
    `).join('');
  }
  
  function loadCustomGame(gameId) {
    const customGames = JSON.parse(localStorage.getItem(CUSTOM_GAMES_KEY) || '[]');
    const game = customGames.find(g => g.id === gameId);
    if (!game) return;
    
    closeMyGamesModal();
    
    // Show loading indicators
    showButtonLoading(timerModeBtn);
    showButtonLoading(normalModeBtn);
    showButtonLoading(unlimitedModeBtn);
    const wordsCount = $id('wordsToClimbCount');
    if (wordsCount) wordsCount.innerHTML = '<div class="loading"></div>';
    
    // Simulate loading delay for better UX
    setTimeout(() => {
      // Load game data but don't start yet
      ladderData = game.words;
      manualFinalWord = game.finalWord;
      manualFinalHint = game.finalHint;
      
      // Update gameConfig to match
      gameConfig.ladderData = game.words;
      gameConfig.finalWord = game.finalWord;
      gameConfig.finalHint = game.finalHint;
      
      // Update subtitle to show game info
      const subtitle = document.querySelector('.subtitle');
      if (subtitle) {
        subtitle.innerHTML = `🎮 ${game.name} <br><small style="opacity:0.7">by ${game.creator || 'Anonymous'}</small><br><button id="playTodaysGameBtn" class="link-btn" style="font-size: 0.9rem; padding: 0.2rem 0.5rem; margin-top: 0.5rem;">Play Today's Game</button>`;
        
        const playTodaysGameBtn = $id('playTodaysGameBtn');
        if (playTodaysGameBtn) {
          playTodaysGameBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            clearSelectedGame();
          });
        }
      }
      
      // Update word count and hide loading
      if (wordsCount) wordsCount.textContent = game.words.length;
      hideButtonLoading(timerModeBtn);
      hideButtonLoading(normalModeBtn);
      hideButtonLoading(unlimitedModeBtn);
    }, 300);
  }
  
  function editCustomGame(gameId) {
    const customGames = JSON.parse(localStorage.getItem(CUSTOM_GAMES_KEY) || '[]');
    const game = customGames.find(g => g.id === gameId);
    if (!game) return;
    
    closeMyGamesModal();
    openBuilderModal();
    
    if (gameNameInput) gameNameInput.value = game.name;
    if (finalWordInput) finalWordInput.value = game.finalWord;
    if (finalHintInput) finalHintInput.value = game.finalHint;
    if (wordBuilderContainer) wordBuilderContainer.innerHTML = '';
    
    game.words.forEach((wordData, index) => {
      let diamonds = '';
      if (wordData.diamondIndex) {
        diamonds = wordData.diamondIndex.map(idx => wordData.word[idx]).join(',');
      }
      createWordBuilderRow(wordData.word, wordData.hint || '', diamonds);
    });
    
    window.editingGameId = gameId;
    const saveBtn = $id('saveGameBtn');
    if (saveBtn) {
      saveBtn.textContent = 'Update Game';
    }
  }
  
  function deleteCustomGame(gameId, confirm = true) {
    if (confirm && !window.confirm('Delete this custom game?')) return;
    
    const customGames = JSON.parse(localStorage.getItem(CUSTOM_GAMES_KEY) || '[]');
    const filtered = customGames.filter(g => g.id !== gameId);
    localStorage.setItem(CUSTOM_GAMES_KEY, JSON.stringify(filtered));
    
    if (confirm) renderMyGames();
  }
  
  function publishCustomGame(gameId) {
    const customGames = JSON.parse(localStorage.getItem(CUSTOM_GAMES_KEY) || '[]');
    const game = customGames.find(g => g.id === gameId);
    if (!game) return;
    
    if (game.published && !game.needsRepublish) {
      alert('This game is already published and locked.');
      return;
    }
    
    const creator = prompt('Enter your name as the creator:', game.creator || 'Anonymous');
    if (!creator) return;
    
    // Convert game data to the format expected by backend
    const gameDataRows = [];
    game.words.forEach(wordData => {
      const row = [wordData.word, wordData.hint || '', ''];
      if (wordData.diamondIndex && wordData.diamondIndex.length > 0) {
        row[2] = wordData.diamondIndex.join(',');
      }
      gameDataRows.push(row);
    });
    // Add final word row
    gameDataRows.push(['FINAL', game.finalWord, game.finalHint]);
    
    // Use JSONP for publishing (Google Apps Script doesn't support CORS for POST)
    window.handlePublishResponse = function(data) {
      if (data && data.status === 'error') {
        alert(`Failed to publish game: ${data.message || data.error || 'Server error'}`);
      } else if (data && (data.success === true || data.status === 'success' || data.result === 'success')) {
        game.published = true;
        game.needsRepublish = false;
        game.creator = creator.trim();
        game.publishedAt = new Date().toISOString();
        
        const gameIndex = customGames.findIndex(g => g.id === gameId);
        if (gameIndex !== -1) {
          customGames[gameIndex] = game;
          localStorage.setItem(CUSTOM_GAMES_KEY, JSON.stringify(customGames));
        }
        
        alert('Game published successfully!');
        renderMyGames();
      } else {
        alert('Publishing is not available - the backend does not support the publishGame action. The game has been saved locally only.');
      }
    };
    
    const script = document.createElement('script');
    const params = new URLSearchParams({
      action: 'publishGame',
      gameId: game.id,
      name: game.name,
      creator: creator.trim(),
      gameDataRows: JSON.stringify(gameDataRows),
      finalWord: game.finalWord,
      finalHint: game.finalHint,
      callback: 'handlePublishResponse',
      _: Date.now()
    });
    script.src = `${_0x3c4d}?${params}`;
    
    const cleanup = () => {
      if (script.parentNode) document.head.removeChild(script);
    };
    
    script.onerror = () => {
      cleanup();
      alert('Failed to publish game. Please check your connection and try again.');
    };
    
    script.onload = () => {
      cleanup();
    };
    
    document.head.appendChild(script);
  }
  
  function parseGameDataFromValues(data) {
    if (!data || !data.values) return null;
    
    const rows = data.values.slice(1);
    const words = [];
    let finalWord = '';
    let finalHint = '';
    
    rows.forEach(row => {
      if (row[0] === 'FINAL') {
        finalWord = row[1] || '';
        finalHint = row[2] || 'A secret word awaits...';
      } else if (row[0] && row[0] !== 'FINAL') {
        const wordData = { word: row[0].toUpperCase() };
        if (row[1]) wordData.hint = row[1];
        if (row[2] !== '' && row[2] !== null && row[2] !== undefined) {
          if (typeof row[2] === 'number') {
            wordData.diamondIndex = [row[2]];
          } else {
            const cellValue = String(row[2]).trim();
            if (cellValue && cellValue !== '') {
              if (cellValue.includes(',')) {
                const indices = cellValue.split(',').map(i => parseInt(i.trim())).filter(i => !isNaN(i));
                if (indices.length > 0) wordData.diamondIndex = indices;
              } else {
                const index = parseInt(cellValue);
                if (!isNaN(index)) wordData.diamondIndex = [index];
              }
            }
          }
        }
        words.push(wordData);
      }
    });
    
    return words.length > 0 ? { words, finalWord, finalHint } : null;
  }
  
});
</script>
<script data-goatcounter="https://thewordladder.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
</body>
</html>
